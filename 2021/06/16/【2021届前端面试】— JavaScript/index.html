<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>【2021届前端面试】— JavaScript | Debug the World</title><meta name="author" content="Joe Xu"><meta name="copyright" content="Joe Xu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【2021届前端面试】— JavaScript1. ES6的新特性？ 字符串扩展：  includes()：返回布尔值，表示是否找到了参数字符串。  startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。  endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。    解构表达式： 数组解构： 1234let arr &#x3D; [1,2,3];const [x,y,z">
<meta property="og:type" content="article">
<meta property="og:title" content="【2021届前端面试】— JavaScript">
<meta property="og:url" content="http://example.com/2021/06/16/%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94%20JavaScript/index.html">
<meta property="og:site_name" content="Debug the World">
<meta property="og:description" content="【2021届前端面试】— JavaScript1. ES6的新特性？ 字符串扩展：  includes()：返回布尔值，表示是否找到了参数字符串。  startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。  endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。    解构表达式： 数组解构： 1234let arr &#x3D; [1,2,3];const [x,y,z">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/67886383?s=400&u=99fc4b7b2788d8823a12f2924f7942669b39b105&v=4">
<meta property="article:published_time" content="2021-06-16T03:42:37.000Z">
<meta property="article:modified_time" content="2023-04-09T08:28:45.729Z">
<meta property="article:author" content="Joe Xu">
<meta property="article:tag" content="前端面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/67886383?s=400&u=99fc4b7b2788d8823a12f2924f7942669b39b105&v=4"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/06/16/%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94%20JavaScript/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":288},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【2021届前端面试】— JavaScript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-09 16:28:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/67886383?s=400&amp;u=99fc4b7b2788d8823a12f2924f7942669b39b105&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Debug the World"><span class="site-name">Debug the World</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【2021届前端面试】— JavaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-06-16T03:42:37.000Z" title="Created 2021-06-16 11:42:37">2021-06-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-04-09T08:28:45.729Z" title="Updated 2023-04-09 16:28:45">2023-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【2021届前端面试】— JavaScript"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="【2021届前端面试】—-JavaScript"><a href="#【2021届前端面试】—-JavaScript" class="headerlink" title="【2021届前端面试】— JavaScript"></a>【2021届前端面试】— JavaScript</h1><h3 id="1-ES6的新特性？"><a href="#1-ES6的新特性？" class="headerlink" title="1. ES6的新特性？"></a>1. ES6的新特性？</h3><ol>
<li><p>字符串扩展：</p>
<ul>
<li><p>includes()：返回布尔值，表示是否找到了参数字符串。</p>
</li>
<li><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</li>
<li><p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
</li>
</ul>
</li>
<li><p>解构表达式：</p>
<p><strong>数组解构：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [x,y,z] = arr;   <span class="comment">// x，y，z将与arr中的每个位置对应来取值</span></span><br><span class="line"><span class="comment">// 然后打印</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x,y,z);</span><br></pre></td></tr></table></figure>

<p><strong>对象解构：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">21</span>,</span><br><span class="line">    <span class="attr">language</span>: [<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解构表达式获取值</span></span><br><span class="line"><span class="keyword">const</span> &#123;name,age,language&#125; = person;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(language);</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数优化:</p>
<p><strong>设置函数参数默认值：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a , b = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传一个参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p><strong>箭头函数：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个参数时：</span></span><br><span class="line"><span class="keyword">var</span> print = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">print2</span> = obj =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数的情况：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sum2</span> = (<span class="params">a,b</span>) =&gt; a+b;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码不止一行，可以用&#123;&#125;括起来</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sum3</span> = (<span class="params">a,b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>map 和 reduce：</p>
<p><strong>map()：</strong>接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p>
<p>举例：有一个字符串数组，我们希望转为int数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;20&#x27;</span>,<span class="string">&#x27;-5&#x27;</span>,<span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">arr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> <span class="built_in">parseInt</span>(s));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure>

<p><strong>reduce()：</strong>接收一个函数（必须）和一个初始值（可选），该函数接收两个参数：第一个参数是上一次reduce处理的结果，第二个参数是数组中要处理的下一个元素。</p>
<p>reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">20</span>,-<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b)) <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>promise：</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里我们用定时任务模拟异步</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> num = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">        <span class="comment">// 随机返回成功或失败</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;成功！num:&quot;</span> + num);  <span class="comment">// 调用resolve，代表Promise将返回成功的结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&quot;出错了！num:&quot;</span> + num);  <span class="comment">// 调用reject，代表Promise会返回失败结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">300</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用promise</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">msg</span>) &#123;   <span class="comment">// 异步执行成功后的回调</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">msg</span>) &#123;   <span class="comment">// 异步执行失败后的回调</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>set和map：</p>
<ul>
<li>Set本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。</li>
<li>map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即：<ul>
<li>object是 &lt;string,object&gt;集合</li>
<li>map是&lt;object,object&gt;集合</li>
</ul>
</li>
</ul>
</li>
<li><p>模块化：</p>
<p>模块化就是把代码进行拆分，方便重复利用。模块功能主要由两个命令构成：export和import。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span>命令用于规定模块的对外接口，</span><br><span class="line"><span class="keyword">import</span>命令用于导入其他模块提供的功能。</span><br></pre></td></tr></table></figure>

<p>export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。当要导出多个值时，还可以简写。</p>
</li>
<li><p>for…of：</p>
<p>for…of 用于遍历一个迭代器，如数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">letters.<span class="property">size</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> letters) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(letter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果: a, b, c</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>class类：</p>
<p>传统的JavaScript中只有对象，没有类的概念。它是基于原型的面向对象语言。原型对象特点就是将自身的属性共享给新对象。ES6 中支持 class 语法，不过，ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。语法糖（Syntactic sugar），也译为糖衣语法，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，糖在不改变其所在位置的语法结构的前提下，实现了运行时的等价。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：代码更简洁流畅，代码更语义自然…</p>
<p>在ES没有class类时，如果要生成一个对象实例，需要先定义一个构造函数，然后通过new操作符来完成。构造函数示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数名和实例化构造名相同且大写（非强制，但这么写有助于区分构造函数和普通函数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我的名字叫&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&quot;今年&quot;</span>+<span class="variable language_">this</span>.<span class="property">age</span>+<span class="string">&quot;岁了&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;laotie&quot;</span>,<span class="number">88</span>);<span class="comment">//通过构造函数创建对象，必须使用new 运算符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">say</span>());<span class="comment">//我的名字叫laotie今年88岁了</span></span><br></pre></td></tr></table></figure>

<p>ES6引入了Class（类）这个概念，通过class关键字可以定义类。该关键字的出现使得其在对象写法上更加清晰，更像是一种面向对象的语言。如果将之前的代码改为ES6的写法就会是这个样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">//定义了一个名字为Person的类</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;<span class="comment">//constructor是一个构造方法，用来接收参数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;<span class="comment">//this代表的是实例对象</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span>=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">say</span>(<span class="params"></span>)&#123;<span class="comment">//这是一个类的方法，注意千万不要加上function</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我的名字叫&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&quot;今年&quot;</span>+<span class="variable language_">this</span>.<span class="property">age</span>+<span class="string">&quot;岁了&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;laotie&quot;</span>,<span class="number">88</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">say</span>());<span class="comment">//我的名字叫laotie今年88岁了</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-ES6-的-class-和构造函数的区别"><a href="#2-ES6-的-class-和构造函数的区别" class="headerlink" title="2. ES6 的 class 和构造函数的区别"></a>2. ES6 的 class 和构造函数的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>严格模式：</span><br><span class="line">类和模块的内部，默认就是严格模式，所以不需要使用<span class="string">`use strict`</span>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 <span class="title class_">ES6</span> 实际上把整个语言升级到了严格模式。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 不存在提升：</span><br><span class="line">类不存在变量提升（hoist），这一点与 <span class="title class_">ES5</span> 完全不同。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 方法默认是不可枚举的：</span><br><span class="line"><span class="title class_">ES6</span> 中的 <span class="keyword">class</span>，它的方法（包括静态方法和实例方法）默认是不可枚举的，而构造函数默认是可枚举的。细想一下，这其实是个优化，让你在遍历时候，不需要再判断 hasOwnProperty 了</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">class</span> 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 <span class="keyword">new</span> 来调用。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="keyword">class</span> 必须使用 <span class="keyword">new</span> 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 <span class="keyword">new</span> 也可以执行。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="title class_">ES5</span> 和 <span class="title class_">ES6</span> 子类 <span class="variable language_">this</span> 生成顺序不同：</span><br><span class="line"><span class="title class_">ES5</span> 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例。<span class="title class_">ES6</span> 的继承先生成父类实例，再调用子类的构造函数修饰父类实例。这个差别使得 <span class="title class_">ES6</span> 可以继承内置对象。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> <span class="title class_">ES6</span> <span class="keyword">class</span> 可以继承静态方法，而构造函数不能。</span><br></pre></td></tr></table></figure>

<h3 id="3-JS的三大事件是什么？"><a href="#3-JS的三大事件是什么？" class="headerlink" title="3. JS的三大事件是什么？"></a>3. JS的三大事件是什么？</h3><p>鼠标事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">click：单击</span><br><span class="line">dblclick：双击</span><br><span class="line">mousedown：鼠标按下</span><br><span class="line">mouseup：鼠标抬起</span><br><span class="line">mouseover：鼠标悬浮</span><br><span class="line">mouseout：鼠标离开</span><br><span class="line">mousemove：鼠标移动</span><br><span class="line">mouseenter：鼠标进入</span><br><span class="line">mouseleave：鼠标离开</span><br></pre></td></tr></table></figure>

<p>键盘事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keydown：按键按下</span><br><span class="line">keyup：按键抬起</span><br><span class="line">keypress：按键按下抬起</span><br></pre></td></tr></table></figure>

<p>HTML事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load：文档加载完成</span><br><span class="line">select：被选中的时候</span><br><span class="line">change：内容被改变</span><br><span class="line">focus：得到光标</span><br><span class="line">resize：窗口尺寸变化</span><br><span class="line">scroll：滚动条移动</span><br></pre></td></tr></table></figure>

<h3 id="4-js判断是不是数组"><a href="#4-js判断是不是数组" class="headerlink" title="4. js判断是不是数组"></a>4. js判断是不是数组</h3><ol>
<li>instanceof 判断</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原型链方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">__proto__</span>.<span class="property">constructor</span> == <span class="title class_">Array</span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">constructor</span> == <span class="title class_">Array</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Object.prototype.toString.call()</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(a) === <span class="string">&#x27;[object Array]&#x27;</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Array.isArray()</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a);  <span class="comment">//返回“object”</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(a));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h3 id="5-js数组常用的操作方法，slice-、splice-、substring-、substr-区别？"><a href="#5-js数组常用的操作方法，slice-、splice-、substring-、substr-区别？" class="headerlink" title="5. js数组常用的操作方法，slice()、splice()、substring()、substr()区别？"></a>5. js数组常用的操作方法，slice()、splice()、substring()、substr()区别？</h3><ol>
<li><p>slice(start,end)：可操作数组和字符串，不修改原数组。方法可从已有数组中返回选定的元素，返回一个新数组，包含从start(包含开始索引)到end(不包含结束索引)的数组元素。注意：该方法不会改变原数组，而是返回一个子数组，如果想删除数组中的一段元素，应该使用Array.splice()方法。</p>
<ul>
<li>start参数：必须，规定从何处开始选取，如果为负数，规定从数组尾部算起的位置，-1是指最后一个元素。</li>
<li>end参数：可选（如果该参数没有指定，那么切分的数组包含从start到数组结束的所有元素，如果这个参数为负数，那么规定是从数组尾部开始算起的元素）。</li>
</ul>
</li>
<li><p>splice()：只能操作数组，该方法向或者从数组中添加或者删除项目，返回被删除的项目。（该方法会改变原数组）。splice（start,deleteCount,item1,…itemX）</p>
<ul>
<li>start参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。</li>
<li>deleteCount参数：必须，要删除的数量，如果为0，则不删除项目。</li>
<li>tem1,…itemX参数：可选，向数组添加的新项目。</li>
</ul>
</li>
<li><p>substring(start,end)：只能操作字符串，返回从start位置开始到end位置的子串（不包含end），不改变原字符串。</p>
</li>
<li><p>substr(start,length)：只能操作字符串，返回从start位置开始length长度的子串，不改变原字符串。</p>
</li>
</ol>
<p>进出栈操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">push</span>(value,...)         数组末端入栈操作</span><br><span class="line"><span class="title function_">pop</span>()                   数组末端出栈操作</span><br><span class="line"><span class="title function_">unshift</span>(value,...)      数组首端入栈操作</span><br><span class="line"><span class="title function_">shift</span>()                 数组首端出栈操作</span><br></pre></td></tr></table></figure>

<p>连接数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">join</span>(bystr)          返回由bystr连接数组元素组成的字符串</span><br><span class="line"><span class="title function_">toString</span>()           返回由逗号连接数组元素组成的字符串</span><br><span class="line"><span class="title function_">concat</span>(value,...)    返回添加参数中元素后的数组</span><br></pre></td></tr></table></figure>

<p>数组排序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">reverse</span>()            返回反向的数组</span><br><span class="line"><span class="title function_">sort</span>()               返回排序后的数组</span><br></pre></td></tr></table></figure>


<h3 id="6-JavaScript-中的常用循环遍历（数组或对象）的方法"><a href="#6-JavaScript-中的常用循环遍历（数组或对象）的方法" class="headerlink" title="6. JavaScript 中的常用循环遍历（数组或对象）的方法"></a>6. JavaScript 中的常用循环遍历（数组或对象）的方法</h3><ol>
<li><p>for 循环：用于遍历数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i,arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while 循环：用于遍历数组，和for效果相同，不过 for 循环可以把定义、条件判断、自增自减操作放到一个条件里执行，代码看起来方便一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cars=[<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Ford&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cars[i])&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(cars[i] + <span class="string">&quot;&lt;br&gt;&quot;</span>)</span><br><span class="line">    i++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>do while 循环：do while 循环是 while 循环的一个变体，它首先执行一次操作，然后才进行条件判断，是 true 的话再继续执行操作，是 false 的话循环结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach 循环：forEach循环，循环数组中每一个元素并采取操作， 没有返回值， 可以不用知道数组长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">i,index</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i,index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>map()方法：map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> tt = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>for of 循环：for of 循环是 Es6 中新增的语句，功能非常强大用来替代 for in 和 forEach，for-of循环不仅支持数组，还支持大多数类数组对象，它允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代(Iterable data)的数据结构,注意它的兼容性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>for..in..和for..of..的区别？</strong>  </p>
<ul>
<li><p>for..in..遍历的是键名，也就是索引；</p>
</li>
<li><p>for..of..可以遍历键值 。</p>
</li>
</ul>
<h3 id="7-js数组去重"><a href="#7-js数组去重" class="headerlink" title="7. js数组去重"></a>7. js数组去重</h3><p>（1）for循环(两次) + 新数组： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">23</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeDuplicatedItem</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i+<span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==arr[j])&#123;</span><br><span class="line">                arr.<span class="title function_">splice</span>(j,<span class="number">1</span>);   <span class="comment">//console.log(arr[j]);</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr2 = <span class="title function_">removeDuplicatedItem</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);</span><br></pre></td></tr></table></figure>

<p>（2）for循环(一次) + 新数组：构建一个新的数组存放结果，for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比，若结果数组中没有该元素，则存到结果数组中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">23</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deleteDump</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> arr1 = [];</span><br><span class="line">    arr1.<span class="title function_">push</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr1.<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>)&#123;</span><br><span class="line">            arr1.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> res = <span class="title function_">deleteDump</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br></pre></td></tr></table></figure>

<p>（3）for循环(一次) + 新数组 + 新对象 ：利用空对象来记录新数组中已经存储过的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">23</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> o=&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> new_arr=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">var</span> k=arr[i];</span><br><span class="line">    <span class="keyword">if</span>(!o[k])&#123;</span><br><span class="line">        o[k]=<span class="literal">true</span>;</span><br><span class="line">        new_arr.<span class="title function_">push</span>(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(new_arr);</span><br></pre></td></tr></table></figure>

<p>（4）for循环(一次) + sort()排序 + 新数组：原数组长度不变但被按字符串顺序排序，借助新数组 ，判断新数组中是否存在该元素如果不存在则将此元素添加到新数组中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法四</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">23</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeRepEle</span>(<span class="params">ar</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [],</span><br><span class="line">    <span class="keyword">var</span> end;  <span class="comment">//临时变量用于对比重复元素</span></span><br><span class="line">    ar.<span class="title function_">sort</span>();   <span class="comment">//将数重新组排序</span></span><br><span class="line">    end = ar[<span class="number">0</span>];</span><br><span class="line">    ret.<span class="title function_">push</span>(ar[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; ar.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ar[i] != end) &#123;   <span class="comment">//当前元素如果和临时元素不等则将此元素添加到新数组中</span></span><br><span class="line">            ret.<span class="title function_">push</span>(ar[i]);</span><br><span class="line">            end = ar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr2 = <span class="title function_">removeRepEle</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//[ 1, 1, 1, 1, 23, 23, 3, 5, 5, 6, 7, 8, 9, 9 ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);<span class="comment">//[ 1, 23, 3, 5, 6, 7, 8, 9 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="8-js数组扁平化"><a href="#8-js数组扁平化" class="headerlink" title="8. js数组扁平化"></a>8. js数组扁平化</h3><p>给定数组：将多维数组转化为一维数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line">str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(ary);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>直接调用ES6的flat()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ary = ary.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);  <span class="comment">// flat里面的参数表示展开的深度，Infinity表示任意深度，也就是完全展开</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = str.<span class="title function_">replace</span>(<span class="regexp">/\[|\]/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = <span class="string">&#x27;[&#x27;</span> + str + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">ary = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ary);</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params">ary</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;ary.<span class="property">length</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">let</span> item = ary[i];</span><br><span class="line">		<span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))&#123;</span><br><span class="line">			<span class="title function_">func</span>(item);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			res.<span class="title function_">push</span>(item);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>(ary));</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">ary</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> ary.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flatten</span>(cur) : cur);</span><br><span class="line">	&#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(ary));</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数组some遍历+扩展运算符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ary.<span class="title function_">some</span>(<span class="title class_">Array</span>.<span class="property">isArray</span>))&#123;</span><br><span class="line">	ary = [].<span class="title function_">concat</span>(...ary); </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ary);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-js数组乱序"><a href="#9-js数组乱序" class="headerlink" title="9. js数组乱序"></a>9. js数组乱序</h3><ol>
<li><p>sort + 随机数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>洗牌算法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shuffle</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> length = arr.<span class="property">length</span>,</span><br><span class="line">	r = length,</span><br><span class="line">	rand = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (r) &#123;</span><br><span class="line">		rand = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * r--);</span><br><span class="line">		[arr[r], arr[rand]] = [arr[rand], arr[r]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">shuffle</span>(arr));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-js函数柯里化"><a href="#10-js函数柯里化" class="headerlink" title="10. js函数柯里化"></a>10. js函数柯里化</h3><p>把接收多个参数的函数 变换成 接收单一参数 的函数，并且 返回接收余下的参数 且 返回结果的 新函数的技术。</p>
<p>使用场景：</p>
<ul>
<li>参数复用；</li>
<li>提前确认，避免每次都重复判断；</li>
<li>延迟计算&#x2F;运行；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通say函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params">school,age,name</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我的学校是<span class="subst">$&#123;school&#125;</span>,年龄是<span class="subst">$&#123;age&#125;</span>,名字是<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">say</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="title function_">say</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;Marry&#x27;</span>);</span><br><span class="line"><span class="title function_">say</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;Lisa&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params">school</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">age</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我的学校是<span class="subst">$&#123;school&#125;</span>,年龄是<span class="subst">$&#123;age&#125;</span>,名字是<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> setSchool = <span class="title function_">say</span>(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> setAge = <span class="title function_">setSchool</span>(<span class="number">24</span>);</span><br><span class="line"><span class="title function_">setAge</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="title function_">setAge</span>(<span class="string">&#x27;Marry&#x27;</span>);</span><br><span class="line"><span class="title function_">setAge</span>(<span class="string">&#x27;Lisa&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数复用</span></span><br><span class="line"><span class="keyword">let</span> setInfo = <span class="title function_">say</span>(<span class="string">&#x27;xxx&#x27;</span>)(<span class="number">24</span>);</span><br><span class="line"><span class="title function_">setInfo</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="title function_">setInfo</span>(<span class="string">&#x27;Marry&#x27;</span>);</span><br><span class="line"><span class="title function_">setInfo</span>(<span class="string">&#x27;Lisa&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装一个公用 函数柯里化的方法</span></span><br><span class="line"><span class="comment">// 参数fn：被柯里化的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">	<span class="comment">// 记录fn的参数个数</span></span><br><span class="line">	<span class="keyword">let</span> len = fn.<span class="property">length</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">temp</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="comment">// 收集本次传递的参数</span></span><br><span class="line">		<span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">		<span class="keyword">if</span>(args.<span class="property">length</span> &gt;= len)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">				<span class="title function_">temp</span>(...args, ...<span class="variable language_">arguments</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = <span class="title function_">curry</span>(say);</span><br><span class="line"><span class="comment">// r(&#x27;xxx&#x27;)(24)(&#x27;Lisa&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数复用</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="title function_">r</span>(<span class="string">&#x27;xxx&#x27;</span>)(<span class="number">24</span>);</span><br><span class="line"><span class="title function_">r1</span>(<span class="string">&#x27;Marry&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="11-js数组的合并"><a href="#11-js数组的合并" class="headerlink" title="11. js数组的合并"></a>11. js数组的合并</h3><ol>
<li>concat 方法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> c=a.<span class="title function_">concat</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 1,2,3,4,5,6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1,2,3  不改变本身</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>循环遍历：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr2.<span class="property">length</span>;i++)&#123;</span><br><span class="line">      arr1.<span class="title function_">push</span>(arr2[i]) </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);<span class="comment">//[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>apply：合并数组arr1和数组arr2,使用Array.prototype.push.apply(arr1,arr2) 或arr1.push.apply(arr1,arr2);</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">apply</span>(arr1,arr2);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">arr1.<span class="property">push</span>.<span class="title function_">apply</span>(arr1,arr2);&lt;br&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">//[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>ES6写法——扩展运算：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">a.<span class="title function_">push</span>(...b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)<span class="comment">//[0,1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> c=[...a, ...b]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)<span class="comment">//[0,1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>ES6写法——使用map()：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>];</span><br><span class="line">arr1.<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">	arr2.<span class="title function_">push</span>(item)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2) <span class="comment">// [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="12-js对象的合并"><a href="#12-js对象的合并" class="headerlink" title="12. js对象的合并"></a>12. js对象的合并</h3><ol>
<li>$.extend()：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1= &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2= &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> c = $.<span class="title function_">extend</span>(obj1, obj2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;a: 1, b: 1&#125;  obj1已被修改</span></span><br><span class="line"><span class="comment">//或者 &lt;br&gt;var obj3 = $.extend(&#123;&#125;, obj1, obj2) &lt;br&gt;console.log(obj3); //&#123;a: 1, b: 1&#125; 不会改变obj1,obj2</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>遍历赋值：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj2)&#123;</span><br><span class="line">     <span class="keyword">if</span>(obj2.<span class="title function_">hasOwnProperty</span>(key)===<span class="literal">true</span>)&#123;<span class="comment">//此处hasOwnProperty是判断自有属性，用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问会避免原型对象扩展带来的干扰</span></span><br><span class="line">           obj1[key]=obj2[key];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);<span class="comment">//&#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3&#125;;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Obj.assign() ：可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。Object.assign(target, …sources)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a. 复制一个对象&lt;br&gt;var obj = &#123; a: 1 ,b:2&#125;;</span></span><br><span class="line"><span class="keyword">var</span> copyObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copyObj); <span class="comment">// &#123; a: 1,b:2 &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.合并多个对象</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(o1, o2, o3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1);  <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 且目标对象自身也会改变。</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>对象的深拷贝和浅拷贝：</p>
<p>4.1 浅拷贝</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;<span class="string">&#x27;b&#x27;</span>:&#123;<span class="string">&#x27;b1&#x27;</span>:<span class="number">22</span>,<span class="string">&#x27;b2&#x27;</span>:<span class="number">33</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">extend</span>(obj1, obj2);   <span class="comment">//obj1拷贝了obj2的属性</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1)  <span class="comment">// &#123;&#x27;a&#x27;:1,&#x27;b&#x27;&#123;&#x27;b1&#x27;:22,&#x27;b2&#x27;:33&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">b1</span>)  <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line">obj2.<span class="property">b</span>.<span class="property">b1</span>=<span class="number">44</span>;   <span class="comment">//obj2重新赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">b1</span>)  <span class="comment">// 44  obj1.b仅拷贝了对象的指引，所以受原obj2的影响 </span></span><br></pre></td></tr></table></figure>

<p>   4.2 深拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;<span class="string">&#x27;b&#x27;</span>:&#123;<span class="string">&#x27;b1&#x27;</span>:<span class="number">22</span>,<span class="string">&#x27;b2&#x27;</span>:<span class="number">33</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">extend</span>(<span class="literal">true</span>,obj1, obj2);   <span class="comment">//第一个参数设为true表示深复制</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1)  <span class="comment">// &#123;&#x27;a&#x27;:1,&#x27;b&#x27;&#123;&#x27;b1&#x27;:22,&#x27;b2&#x27;:33&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">b1</span>)  <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line">obj2.<span class="property">b</span>.<span class="property">b1</span>=<span class="number">44</span>;   <span class="comment">//obj2重新赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">b1</span>)  <span class="comment">// 22 obj1拷贝了obj2的所有属性以及值，并不受obj2的影响</span></span><br></pre></td></tr></table></figure>



<h3 id="13-let-var-const区别"><a href="#13-let-var-const区别" class="headerlink" title="13. let var const区别"></a>13. let var const区别</h3><ul>
<li><p>let是块状作用域，而var是函数作用域。</p>
</li>
<li><p>let: let 不能被重新定义，允许你声明一个作用域被限制在块级中的变量、语句或者表达式，let 绑定不受变量提升的约束，这意味着let声明不会被提升到当前，该变量处于从块开始到初始化处理的”临时死区”。</p>
</li>
<li><p>var: 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的, 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。</p>
</li>
<li><p>const 声明创建一个值的只读引用 (即指针)，这里就要介绍下 JS 常用类型: String、Number、Boolean、Array、Object、Null、Undefined。其中基本类型有 Undefined、Null、Boolean、Number、String，保存在栈中；复合类型 有 Array、Object ，保存在堆中； 基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 const申明基本数据类型时，再将其值改变时，会造成报错， 例如 const a &#x3D; 3 ; a &#x3D; 5 时 将会报错；但是如果是复合类型时，如果只改变复合类型的其中某个Value项时， 还是正常使用。</p>
</li>
</ul>
<ol>
<li>   var声明的变量会挂载到window上，而let和const的变量不会；</li>
<li>   var声明的变量存在变量提升，let和const不存在变量提升；</li>
<li>   let和const声明形成块作用域；</li>
<li>   同一作用域下，let和const不能声明同名变量，而var可以；</li>
<li>   let声明的是变量，const声明的是常量，只读，修改值会报错，const保存的是内存地址，可以给数组或对象添加属性或元素，但是不能重复复写。</li>
</ol>
<p>声明提升：JS在编译阶段，编译器的一部分工作就是找到所有声明，并用合适的作用域将他们关联起来。所有声明（变量和函数）都会被移动到各自作用域的最顶端，这个过程被称为提升。</p>
<h3 id="14-JS强制类型转换函数"><a href="#14-JS强制类型转换函数" class="headerlink" title="14. JS强制类型转换函数"></a>14. JS强制类型转换函数</h3><ul>
<li>函数parseInt：强制转换成整数。例如parseInt(“6.12”)&#x3D;6  ; parseInt(“12a”)&#x3D;12 ; parseInt(“a12”)&#x3D;NaN  ;parseInt(“1a2”)&#x3D;1</li>
<li>函数parseFloat：强制转换成浮点数。parseFloat(“6.12”)&#x3D;6.12</li>
<li>函数eval：将字符串强制转换为表达式并返回结果。eval(“1+1”)&#x3D;2 ; eval(“1&lt;2”)&#x3D;true</li>
</ul>
<h3 id="15-Parseint-、Math-round-、Math-floor-、Math-ceil-四种取整方法的区别？"><a href="#15-Parseint-、Math-round-、Math-floor-、Math-ceil-四种取整方法的区别？" class="headerlink" title="15. Parseint()、Math.round()、Math.floor()、Math.ceil()四种取整方法的区别？"></a>15. Parseint()、Math.round()、Math.floor()、Math.ceil()四种取整方法的区别？</h3><ul>
<li>Parseint()：直接舍弃小数部分，只保留整数部分。parseInt(string, radix) 函数可解析一个字符串，并返回一个整数。string：必需，要被解析的字符串；radix：可选。表示要解析的数字是几进制的，解析出的结果是十进制数。参数介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。可用来进制转换。</li>
<li>Math.round()：表示四舍五入取整。</li>
<li>Math.floor()：floor地板，表示向下取整。</li>
<li>Math.ceil()：ceil天花板，表示向上取整。</li>
</ul>
<h3 id="16-null和undefined的区别？"><a href="#16-null和undefined的区别？" class="headerlink" title="16. null和undefined的区别？"></a>16. null和undefined的区别？</h3><ul>
<li>null转为数字类型为0，undefined转为数字类型为NaN；</li>
<li>undefined是代表一个值而该值却没有赋值，这时候默认为undefined；</li>
<li>null是一个很特殊的对象，最为常见的用法就是作为参数传入；</li>
<li>设置为null的变量或者对象会被内存收集器回收；</li>
</ul>
<p>null是表示空值，对其做typeof ，得到的是object，是一个特殊的对象 。</p>
<p>undefined表示“缺少值”，就是此处应该有一个值，但是还没有定义。</p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2）调用函数时，应该提供的参数没有提供，该参数就等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。</p>
<h3 id="17-JS深浅拷贝"><a href="#17-JS深浅拷贝" class="headerlink" title="17. JS深浅拷贝"></a>17. JS深浅拷贝</h3><p>ECMAScript中的数据类型可分为两种：（判断基本数据类型用typeOf，判断引用类型用instanceOf）  </p>
<ul>
<li>基本类型：undefined, null, Boolean, String, Number, Symbol；</li>
<li>引用类型：Object, Array, Date,  Function, RegExp等；</li>
</ul>
<p>不同类型的存储方式：</p>
<ul>
<li>基本类型：基本类型值在内存中占据固定大小，保存在栈内存中。</li>
<li>引用类型：引用类型的值是对象，保存在堆内存中，而栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。</li>
</ul>
<p>不同类型的复制方式：</p>
<ul>
<li>基本类型：从一个变量向另外一个新变量复制基本类型的值，会创建这个值的一个副本，并将该副本复制给新变量。修改其中一个的值不会改变另一个值。</li>
<li>引用类型：从一个变量向另一个新变量复制引用类型的值，其实复制的是指针，最终两个变量都指向同一个对象。修改其中一个的值会影响另一个值。</li>
</ul>
<p><strong>浅拷贝：</strong> 仅仅是复制了引用，彼此之间的操作会互相影响。</p>
<p><strong>深拷贝：</strong> 在堆中重新分配内存，不同的地址，相同的值，互不影响。 </p>
<p>深拷贝的实现：</p>
<ol>
<li><p>递归实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归方法，进行深拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">     <span class="comment">//传进来的参数如果是数组选择[]，如果不是数组选择&#123;&#125;</span></span><br><span class="line">     <span class="keyword">let</span> objClone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">     <span class="comment">//判断传进来的是不是object类型，如果是基本类型就直接返回。</span></span><br><span class="line">     <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span>(key <span class="keyword">in</span> obj) &#123;  <span class="comment">//枚举遍历</span></span><br><span class="line">                <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;  <span class="comment">//判断obj是否有该名称的属性或对象</span></span><br><span class="line">                   <span class="comment">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class="line">                   <span class="keyword">if</span>(obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                         objClone[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;<span class="comment">//当递归到子元素不是对象时、简单复制</span></span><br><span class="line">                      <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                      objClone[key] = obj[key];</span><br><span class="line">                 　&#125;</span><br><span class="line">           　　&#125;</span><br><span class="line">      　　&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>
</li>
<li><p>json实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(people))</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="18-JS闭包的概念？优缺点？"><a href="#18-JS闭包的概念？优缺点？" class="headerlink" title="18. JS闭包的概念？优缺点？"></a>18. JS闭包的概念？优缺点？</h3><p>闭包的概念：闭包就是能读取其他函数内部变量的函数。</p>
<p>闭包的定义即：函数 <code>A</code> 内部有一个函数 <code>B</code>，函数 <code>B</code> 可以访问到函数 <code>A</code> 中的变量，那么函数 <code>B</code> 就是闭包。</p>
<p>优点：</p>
<ol>
<li>避免全局变量的污染；</li>
<li>希望一个变量长期存储在内存中（缓存变量）；</li>
</ol>
<p>缺点：</p>
<ol>
<li>内存泄露（消耗）；</li>
<li>常驻内存，增加内存使用量；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;</span><br><span class="line">        local++;</span><br><span class="line">        <span class="keyword">return</span> local</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure>



<h3 id="19-js-执行机制、事件循环、异步编程方法"><a href="#19-js-执行机制、事件循环、异步编程方法" class="headerlink" title="19. js 执行机制、事件循环、异步编程方法"></a>19. js 执行机制、事件循环、异步编程方法</h3><p> JavaScript  语言的一大特点就是单线程，同一个时间只能做一件事。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript 语言的设计者意识到这个问题，将所有任务分成两种，一种是<strong>同步任务（synchronous），另一种是异步任务（asynchronous）</strong>，在所有同步任务执行完之前，任何的异步任务是不会执行的。当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。</p>
<p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。当<strong>指定的事情完成时</strong>，Event Table 会将这个函数移入 Event Queue。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的 Event Loop(事件循环)。我们不禁要问了，那怎么知道主线程执行栈为空啊？js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。</p>
<p>说完 JS 主线程的执行机制，下面说说经常被问到的 JS 异步中 <strong>宏任务（macrotasks）</strong>、<strong>微任务（microtasks）</strong> 执行顺序。JS 异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入 Event Queue，然后再执行微任务，将微任务放入 Event  Queue，但是，这两个 Queue 不是一个 Queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的 Queue  拿宏任务的回调函数。</p>
<ul>
<li>宏任务：当前调用栈中执行的任务称为宏任务。（主代码块，定时器等等），整体代码 script，setTimeout，setInterval。</li>
<li>微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，process.nextTick等等）。</li>
<li>宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</li>
</ul>
<p><strong>异步编程方法：</strong></p>
<ol>
<li><p>回调函数：给耗时长的函数添加回调函数，这个回调函数是原本这个任务执行完成之后要执行的函数，来达到避免后续函数执行被前面的函数阻塞。被作为参数传递到另一个函数（主函数）的那个函数就叫做 <strong>回调函数</strong>。</p>
</li>
<li><p>promise对象：ES6新特性Promise，可以将异步操作以同步操作的流程表达出来，避免层层嵌套的回调函数。new  Promise()构造函数接受一个函数作为参数，这个函数又接受两个参数分别为resolve和reject方法。如果异步操作完成，就调用resolve方法将Promise对象实例的状态变为“成功”（从pending到resolved）；如果异步操作失败，就用reject方法将Promise对象实例的状态变成失败（从pending到rejected）。</p>
<p>.then方法，分别给resolve方法和reject方法指定回调函数。</p>
</li>
<li><p>事件监听：给耗时长的函数绑定一事件，事件触发后就执行后来的函数。</p>
</li>
</ol>
<h3 id="20-this的指向问题，普通函数和箭头函数的this，怎么改变普通函数里面的this指向？"><a href="#20-this的指向问题，普通函数和箭头函数的this，怎么改变普通函数里面的this指向？" class="headerlink" title="20. this的指向问题，普通函数和箭头函数的this，怎么改变普通函数里面的this指向？"></a>20. this的指向问题，普通函数和箭头函数的this，怎么改变普通函数里面的this指向？</h3><p><strong>普通函数调用时的this指向问题：</strong></p>
<p> 1、纯函数调用时，this指向window;<br> 2、事件调用时，谁调用指向谁；<br> 3、定时器调用时，this指向window；<br> 4.、构造函数调用时，this指向构造函数生成的这个新的对象；<br> 5、apply 调用时，this指向它的第一个参数。</p>
<p><strong>this指向如何改变?</strong></p>
<p>JS中改变this指向有三个封装好的方法：<br> 1、call（参数1（写谁是谁），实参）<br> 2、apply（参数1（写谁是谁），[N个实参]）<br> 3、bind（）返回值为一个修改完this指向的函数，需要主动调用。<br> 例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  f=fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>.<span class="property">a</span>.<span class="property">b</span>...)</span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>

<p><strong>箭头函数和普通函数的区别？</strong></p>
<p> 1、箭头函数作为匿名函数，不能作为构造函数，不能使用new运算符；<br> 2、箭头函数不绑定auguments，取而代之的使用rest参数代替；<br> 3、箭头函数不绑定this，但会捕获其上下文的this值，作为自己的this值；<br> 4、箭头函数通过call()或者apply()方法调用一个函数时，只传入一个参数，对this没有影响；<br> 5、箭头函数当方法使用的时候，没有定义this绑定；<br> 6、箭头函数没有原型属性；<br> 7、箭头函数不能当做Generator函数，不能使用yiel关键字。</p>
<p>总之，箭头函数的this指向永远指向其上下文的this，任何方法都改变不了，而普通函数的this指向调用它的那个对象。</p>
<p><strong>普通函数中的this:</strong></p>
<p>1.this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj；</p>
<p>2.在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window （常见的window的属性和方法有: alert, location,document,parseInt,setTimeout,setInterval等）(约定俗成)；</p>
<p>3.在严格模式下,没有直接调用者的函数中的this是 undefined；</p>
<p>4.使用call,apply,bind(ES5新增)绑定的,this指的是绑定的对象；</p>
<p><strong>箭头函数中的this：</strong></p>
<p>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this。即使是call，apply，bind等方法也不能改变箭头函数this的指向。</p>
<p>要整明白这些, 我们需要首先了解一下作用域链:当在函数中使用一个变量的时候，首先在本函数内部查找该变量，如果找不到则找其父级函数，最后直到window，全局变量默认挂载在window对象下。</p>
<p><strong>this的四种绑定规则：</strong></p>
<ul>
<li><p>默认绑定：全局范围内，没有直接调用者，this指的是Window对象；若是严格模式，则this为undefined。</p>
</li>
<li><p>隐式绑定：当调用一个对象的方法时，就会发生隐式绑定，this指向调用该方法的对象。</p>
</li>
<li><p>硬绑定：用call和apply方法，就不会把原对象的”小红”暴露出来，只会打印”小白”和”小黄”。想绑定哪个对象，就绑定哪个对象。</p>
</li>
<li><p>构造函数绑定：创建一个构造函数然后进行实例化，this就会和实例化后的新对象进行捆绑。</p>
</li>
</ul>
<h3 id="21-call和apply的区别？"><a href="#21-call和apply的区别？" class="headerlink" title="21. call和apply的区别？"></a>21. call和apply的区别？</h3><ul>
<li><p>call的语法：函数名.call(obj,参数1,参数2,参数3……);</p>
</li>
<li><p>apply的语法：函数名.apply(obj,[参数1,参数2,参数3……]);</p>
</li>
</ul>
<p><strong>相同点：</strong></p>
<p>1.call()和apply()都可以用来间接调用函数，都可以显式调用所需的this。即，任何函数可以作为任何对象的方法来调用。</p>
<p>2.两个方法都可以指定调用实参。</p>
<p><strong>区别：</strong></p>
<p>call()和apply()的基本区别：在于将参数传递给函数。</p>
<p>call():  需要使用逗号分隔列出所有参数。</p>
<p>apply()：要求以数组的形式传入参数，需要注意的是即使只有一个参数，也必须写在数组里面。 </p>
<h3 id="22-apply、call、bind区别？以及如何用apply实现bind函数？"><a href="#22-apply、call、bind区别？以及如何用apply实现bind函数？" class="headerlink" title="22. apply、call、bind区别？以及如何用apply实现bind函数？"></a>22. apply、call、bind区别？以及如何用apply实现bind函数？</h3><ol>
<li>call 方法第一个参数是this的指向，后面传入的是一个参数列表。当第一个参数为null、undefined的时候，默认指向window。如：getColor.call(obj, ‘yellow’, ‘blue’, ‘red’)；</li>
<li>apply  方法接受两个参数，第一个参数是this的指向，第二个参数是一个参数数组。当第一个参数为null、undefined的时候，默认指向window。如：getColor.apply(obj, [‘yellow’, ‘blue’, ‘red’])；</li>
<li>bind 方法和 call 方法很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数以及bind接收的参数列表的使用。低版本浏览器没有该方法，需要自己手动实现。</li>
</ol>
<p>在JavaScript中，call和apply都是为了改变某个函数运行时的上下文而存在的，换句话说就是为了改变函数体内部的this指向。bind是返回对应函数，便于稍后使用; apply、call则是立即调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">let</span> person1 = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="title function_">say</span>(<span class="params">...args</span>)&#123;   <span class="comment">// 剩余参数语法允许我们将一个不定数量的参数表示为一个数组</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`姓名:<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,年龄:<span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>,参数:<span class="subst">$&#123;args&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(args)</span><br><span class="line">            args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(args,<span class="number">0</span>)</span><br><span class="line">            args.<span class="title function_">push</span>(<span class="number">8</span>)   <span class="comment">// push是真数组才有的方法</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(args)</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// person2想借用person1中的say方法</span></span><br><span class="line">    <span class="keyword">let</span> person2 = &#123;    </span><br><span class="line">            <span class="attr">name</span>:<span class="string">&quot;李四&quot;</span>,</span><br><span class="line">            <span class="attr">age</span>:<span class="number">23</span>,  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 1.call 第一个参数：借用方法的对象(这里是person2借用say方法)，后面还可以传递多个参数</span></span><br><span class="line">    person1.<span class="property">say</span>.<span class="title function_">call</span>(person2,<span class="number">1234</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.apply 第一个参数：借用方法的对象(这里是person2借用say方法)，允许传递的第二个参数必须是数组</span></span><br><span class="line">	person1.<span class="property">say</span>.<span class="title function_">apply</span>(person2,[<span class="number">1234</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.bind 第一个参数：借用方法的对象(这里是person2借用say方法)，后面还可以传递多个参数，因为bind          方法返回值为函数，所以执行要加括号</span></span><br><span class="line">	person1.<span class="property">say</span>.<span class="title function_">bind</span>(person2,<span class="number">1234</span>,<span class="number">2</span>,<span class="number">4</span>)()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//会遇到的面试题：</span></span><br><span class="line">		<span class="comment">// 1) 如何将伪数组转换成真数组(见上)</span></span><br><span class="line">			<span class="comment">// 伪数组：就是具备length属性，但不能使用真数组的方法</span></span><br><span class="line">			<span class="comment">// 怎么产生的伪数组：querySelectAll,getElementsByClassName,getElementsByTagName,arugments</span></span><br><span class="line">		<span class="comment">// 2) 怎么无侵入无序数组求最大值</span></span><br><span class="line">			<span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">56</span>,<span class="number">8</span>,<span class="number">666</span>]</span><br><span class="line">            <span class="keyword">let</span> res1 = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>,arr)</span><br><span class="line">            <span class="keyword">let</span> res2 = <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">call</span>(<span class="literal">null</span>,...arr)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>手动用apply实现bind函数：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">obj = <span class="variable language_">window</span>, ...args</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...params</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> self.<span class="title function_">apply</span>(obj, args.<span class="title function_">concat</span>(params))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-DOM-事件有哪些阶段-事件流-？谈谈对事件代理-x2F-事件委托的理解"><a href="#23-DOM-事件有哪些阶段-事件流-？谈谈对事件代理-x2F-事件委托的理解" class="headerlink" title="23. DOM 事件有哪些阶段(事件流)？谈谈对事件代理&#x2F;事件委托的理解"></a>23. DOM 事件有哪些阶段(事件流)？谈谈对事件代理&#x2F;事件委托的理解</h3><p><img src="/2021/06/16/%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94%20JavaScript/d0f50b9295f425e393a9672a2e28696e.png" alt="img"></p>
<p>图为事件流的全过程，从图中我们可以看出：</p>
<ul>
<li>一个完整的事件流是从window开始，最后回到window的一个过程；</li>
<li>事件流被分为3个阶段：1-5捕获阶段，5-6:目标阶段，6-10:冒泡阶段。</li>
</ul>
<p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerHTML)’)。</p>
<p>事件委托得以实现的前提是事件具有冒泡机制，就像涟漪一样，子元素的事件会继续蔓延传递到父元素上，那么就可以通过监听父元素，再利用target判断事件的具体触发源头，进而监听父元素内任意子元素的事件。</p>
<p>Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用event.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="keyword">var</span> oUl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;ul1&quot;</span>);</span><br><span class="line">　　oUl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">ev</span>)&#123;</span><br><span class="line">　　	 <span class="comment">// 兼容性处理：</span></span><br><span class="line">　　　　<span class="keyword">var</span> event = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">　　　　<span class="keyword">var</span> target = event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line">　　　　</span><br><span class="line">　　　　<span class="keyword">if</span>(target.<span class="property">nodeName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line">　 　　　　　　 <span class="title function_">alert</span>(<span class="number">123</span>);</span><br><span class="line">　　　　　　　  <span class="title function_">alert</span>(target.<span class="property">innerHTML</span>);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件委托的优点，一是可以将批量元素监听的任务通过一个监听实现，优化页面性能；二是可以实现对动态生成子元素的监听(新添加的子元素是带有事件效果的)，某些场景下非常有用。好处：(1)使代码更简洁；(2)节省内存开销。</p>
<h3 id="24-一个DOM元素绑定多个事件时，先执行冒泡还是捕获？"><a href="#24-一个DOM元素绑定多个事件时，先执行冒泡还是捕获？" class="headerlink" title="24. 一个DOM元素绑定多个事件时，先执行冒泡还是捕获？"></a>24. 一个DOM元素绑定多个事件时，先执行冒泡还是捕获？</h3><p>无论是冒泡事件还是捕获事件，元素都会先执行捕获阶段。从上往下，如果有捕获事件，则执行；一直下到目标元素后，从目标元素开始向上执行冒泡元素，即第三个参数为false的绑定事件的元素。(在向上执行过程中，已经执行过的捕获事件不再执行，只执行冒泡事件)。</p>
<h3 id="25-DOM事件event对象中target和currentTarget的区别？"><a href="#25-DOM事件event对象中target和currentTarget的区别？" class="headerlink" title="25. DOM事件event对象中target和currentTarget的区别？"></a>25. DOM事件event对象中target和currentTarget的区别？</h3><p>target是事件触发的真实元素；currentTarget是事件绑定的元素。</p>
<p>this和currentTarget的关系：在事件处理程序内部，对象this始终等于currentTarget的值。</p>
<p>currentTarget和target，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡）</p>
<ul>
<li>当事件是子元素触发时，currentTarget为绑定事件的元素，target为子元素。</li>
<li>当事件是元素自身触发时，currentTarget和target为同一个元素。</li>
</ul>
<h3 id="26-JS中DOM事件中一些常见的浏览器兼容问题"><a href="#26-JS中DOM事件中一些常见的浏览器兼容问题" class="headerlink" title="26. JS中DOM事件中一些常见的浏览器兼容问题"></a>26. JS中DOM事件中一些常见的浏览器兼容问题</h3><ol>
<li><p>事件监听&#x2F;事件绑定：</p>
<ul>
<li><p>node.addEventListener(事件类型，事件处理函数，false)		 IE9以下不兼容。</p>
</li>
<li><p>node.attachEvent(“on”+事件类型，事件处理函数)			          IE11以下兼容，11不兼容。</p>
</li>
</ul>
<p>所以需要封装兼容写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addEvent</span>(<span class="params">node,etype,fn</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">addEventListener</span> node.<span class="title function_">addEventListener</span>(etype,fn,<span class="literal">false</span>):node.<span class="title function_">attachEvent</span>(<span class="string">&quot;on&quot;</span>+etype,fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`node代表节点对象；etype表示事件类型；fn为事件处理函数`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件冒泡：常见缺点：就是具有穿透性，易多级触发具有相同事件的父元素事件，同时覆盖外部相同事件。<br>一般处理事件冒泡主要有两种方法：</p>
<ul>
<li>event.stopPropagation()方法，         适用于标准浏览器，IE9以下不支持。</li>
<li>event.cancelBubble &#x3D; true;                IE全系列支持。</li>
</ul>
<p> 兼容写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stopBubble</span>(<span class="params">event</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> event.<span class="property">stopPropagation</span>?event.<span class="title function_">stopPropagation</span>():event.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件触发对象：目标获取：主要依靠事件下的属性获取；</p>
<ul>
<li>event.target;	                此方法标准浏览器兼容，IE9以下不兼容。</li>
<li>event.srcElement;	       这是IE方法，全系列支持。</li>
</ul>
<p>兼容写法：利用短路运算；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  target = event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br></pre></td></tr></table></figure>

<p>可以配合事件冒泡，进行事件委托，所谓事件委托就是需要对子元素进行事件操作，而不是在子元素上直接添加事件，改由在父元素上添加事件，同时获取事件对象后后，使用<code>event.target</code>指向当前操作的子元素。</p>
</li>
<li><p>默认事件的阻止：</p>
<ul>
<li>event.preventDefault()	             标准浏览器   IE9以上支持，以下不支持</li>
<li>event.returnValue &#x3D; false;	        IE9以下支持，以上不支持</li>
</ul>
<p>可以看出IE9之前使用 event.returnValue &#x3D; false; 来阻止默认事件，从IE9开始改为使用标准方法event.preventDefault() 阻止默认行为。<br>需要兼容IE9以下的需要考虑兼容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stopDefault</span>(<span class="params">event</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> event.<span class="property">preventDefault</span>?event.<span class="title function_">preventDefault</span>():event.<span class="property">returnValue</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="27-JavaScript绑定事件的方法"><a href="#27-JavaScript绑定事件的方法" class="headerlink" title="27. JavaScript绑定事件的方法"></a>27. JavaScript绑定事件的方法</h3><ol>
<li><p>在DOM元素中直接绑定：属性赋值 ，这个在该元素的properties属性中可以查到， 也可以在事件监听中看到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;show&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;print&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发的方法只有show方法:</span></span><br><span class="line">&lt;button onclick=<span class="string">&quot;show()&quot;</span> id=<span class="string">&quot;btn1&quot;</span> onclick=<span class="string">&quot;print()&quot;</span>&gt;html标签事件绑定&lt;/button&gt;</span><br><span class="line"><span class="comment">//一个事件，触发两个方法:</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;show();print()&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>html标签事件绑定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在JavaScript代码中绑定：属性赋值，这个在该元素的properties属性中可以查到，也可以在事件监听中看到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn2&quot;</span>&gt;js事件绑定&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn2&quot;</span>).<span class="property">onclick</span> = show;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn2&quot;</span>).<span class="property">onclick</span> = print;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>  </span><br><span class="line"><span class="comment">//注：给一个事件绑定多个操作只会执行最后一个</span></span><br><span class="line"><span class="comment">//只能触发print方法，如果需要同时触发两个方法，只能使用事件监听</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定事件监听函数：用 addEventListener() 或 attachEvent() 来绑定事件监听函数，只可以在该元素的事件监听中看到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn3&quot;</span>&gt;事件监听&lt;/button&gt;      </span><br><span class="line"></span><br><span class="line"><span class="comment">//show和print两个方法都可以触发</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn3&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,show);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn3&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,print);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除事件监听</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn3&quot;</span>).<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，这里的事件名称没有&quot;on&quot;，如鼠标单击事件 click ，鼠标双击事件 doubleclick ，鼠标移入事件 mouseover，鼠标移出事件 mouseout 等。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="28-jQuery中绑定事件on和bind的区别"><a href="#28-jQuery中绑定事件on和bind的区别" class="headerlink" title="28. jQuery中绑定事件on和bind的区别?"></a>28. jQuery中绑定事件on和bind的区别?</h3><p>.bind(events [,eventData], handler)</p>
<p>.on(events [,selector] [,data], handler)</p>
<p>从上可以看出，.on方法比.bind方法多一个参数’selector’，.on的selector参数是筛选出调用.on方法的dom元素的指定子元素，如：$(‘ul’).on(‘click’, ‘li’, function(){console.log(‘click’);})就是筛选出ul下的li给其绑定click事件。selector参数的好处是可以进行事件委托。</p>
<h3 id="29-js原型链-https-www-cnblogs-com-jzhey-p-12582506-html"><a href="#29-js原型链-https-www-cnblogs-com-jzhey-p-12582506-html" class="headerlink" title="29. js原型链 (https://www.cnblogs.com/jzhey/p/12582506.html)"></a>29. js原型链 (<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jzhey/p/12582506.html">https://www.cnblogs.com/jzhey/p/12582506.html</a>)</h3><p>每个构造函数都有一个prototype属性，我们称之为显式原型对象，每个实例对象都有一个__proto__属性，我们称之为隐式原型对象，他们都是指向同一个原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pig = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;peiqi&#x27;</span>,<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pig)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>任何的对象都是new Object()出来的。</p>
</li>
<li><p>Object()也是一个构造函数，所以他在栈上存了一个Object的变量，对应的是堆上的函数对象，这个对象在堆上的内存地址是0x444，并且里面还装了一个prototype属性（构造函数身上必有一个prototype属性），他在堆内存中也开了一块地址，去存他的prototype，内存地址为0x555。</p>
</li>
<li><p>原型对象（不管是显式原型对象还是隐式原型对象）都是普通对象，他不能加（）运行，他相当于是通过new Object（）产生的，所以所有的普通对象都有一个__proto__属性，并且</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通对象.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Animal的显式原型对象也是普通对象，所以他的显式原型对象中有一个__proto__属性，它指向Object的显式原型对象。</p>
</li>
<li><p>Object.prototype._<em>proto</em>_ &#x3D; null 。</p>
</li>
</ol>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oD8tROPU-1600183118869)(C:%5CUsers%5CJoe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200804105157846.png)]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数的prototype属性指向构造函数的原型，构造函数原型的contructor属性指向构造函数，构造函数生成的实例的\__proto__属性指向构造函数的原型。</span><br><span class="line"></span><br><span class="line"><span class="title class_">JavaScript</span>中的对象，都有一个内置属性[[protoType]]，指向这个对象的原型对象。当查找一个属性或者方法时，如果在当前对象找不到定义，会继续在当前对象的原型对象中查找；如果原型对象中依然没有找到，会继续在原型对象的原型中查找(原型也是对象，也有它自己的原型)；如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回<span class="literal">undefined</span>。</span><br></pre></td></tr></table></figure>



<h3 id="30-原型对象和构造函数"><a href="#30-原型对象和构造函数" class="headerlink" title="30. 原型对象和构造函数"></a>30. 原型对象和构造函数</h3><p>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会自带一个prototype属性，这个属性指向函数的原型对象。当函数经过new调用时，这个函数就成为了构造函数，返回了一个全新的实例对象，这个实例对象有一个__proto__属性，指向构造函数的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foo构造函数，foo为Foo的一个实例对象</span></span><br><span class="line">foo.<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>另外，尽量用 Foo.prototype 来访问原型，而不要用 _<em>proto</em>_ 来访问原型，如果一定要通过实例访问原型，可以用ES6的 Object.getPrototypeOf(foo)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(foo) === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(foo) === foo.<span class="property">__proto__</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="31-js-new一个对象的过程"><a href="#31-js-new一个对象的过程" class="headerlink" title="31. js new一个对象的过程"></a>31. js new一个对象的过程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Mother</span>(<span class="params">lastName</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">lastName</span> = lastName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> <span class="title class_">Mother</span>(<span class="string">&quot;Da&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建一个新对象：son；</p>
</li>
<li><p>新对象会被执行[[prototype]]连接；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">son.<span class="property">__proto__</span> = <span class="title class_">Mother</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新对象和函数调用的this会绑定起来；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Mother</span>.<span class="title function_">call</span>(son,<span class="string">&quot;Da&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行构造函数中的代码；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">son.<span class="property">lastName</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果函数没有返回值，那么就会自动返回这个新对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="32-js继承的几种方式及优缺点？"><a href="#32-js继承的几种方式及优缺点？" class="headerlink" title="32. js继承的几种方式及优缺点？"></a>32. js继承的几种方式及优缺点？</h3><ol>
<li><p>原型链继承：将子对象的prototype指向父对象的一个实例。引用类型的属性被所有实例共享，且创建子类实例时，无法向父类构造函数传参。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Supper</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">supProp</span> = <span class="string">&#x27;Supper property&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Supper</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showSupperProp</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supProp</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">subProp</span> = <span class="string">&#x27;Sub property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型的原型为父类型的一个实例对象(原型链继承的关键一步)</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Supper</span>();</span><br><span class="line"><span class="comment">// 让子类型的原型的constructor指向子类型</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span>;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showSubProp</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">subProp</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">sub.<span class="title function_">showSubProp</span>();</span><br><span class="line">sub.<span class="title function_">showSupperProp</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型的属性被所有实例共享</span></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">sub1.<span class="property">a</span>.<span class="title function_">push</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sub1.<span class="property">a</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sub2.<span class="property">a</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/2021/06/16/%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94%20JavaScript/20200915232213771.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li><p>借用构造函数：使用call或apply方法，将父对象的构造函数绑定在子对象上。解决了引用值共享的问题，但只能继承父类的实例属性和方法，不能继承原型属性&#x2F;方法，没办法拿到原型上的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借用构造函数继承(假的继承)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name,age,price</span>)&#123;</span><br><span class="line"><span class="comment">// 在子类型构造函数中通过call()调用父类型构造函数</span></span><br><span class="line">	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name,age);  <span class="comment">// 相当于 this.Person(name.age)</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">20</span>,<span class="number">14000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">name</span>,s.<span class="property">age</span>,s.<span class="property">price</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合继承（伪经典继承）：组合继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。注意要修正子类型的原型的constructor指向子类型。缺点：调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型链+借用构造函数的组合继承</span></span><br><span class="line"><span class="comment">// 1.利用原型链实现对父类型对象的方法继承</span></span><br><span class="line"><span class="comment">// 2.利用call()借用父类型构造函数初始化相同属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name,age,price</span>)&#123;</span><br><span class="line">    <span class="comment">// 在子类型构造函数中通过call()调用父类型构造函数</span></span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name,age);  <span class="comment">// 为了得到属性,借用构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 原型链继承，为了能拿到父类型的方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>; <span class="comment">// 修正constructor属性</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setPrice</span> = <span class="keyword">function</span>(<span class="params">price</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">18</span>,<span class="number">12000</span>);</span><br><span class="line">s.<span class="title function_">setName</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">s.<span class="title function_">setPrice</span>(<span class="number">15000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">name</span>,s.<span class="property">age</span>,s.<span class="property">price</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生组合继承（经典继承）：Sub.prototype &#x3D; Object.create(Super.prototype) 解决了组合继承父类调用两次的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 兼容性写法：</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title class_">Object</span>.<span class="property">create</span>)&#123;</span><br><span class="line">	<span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params">proto</span>)&#123;</span><br><span class="line">		<span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">		F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES5写法：</span></span><br><span class="line"><span class="comment">// 指定Sub.prototype的原型为Super.prototype</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line"><span class="comment">// sub1.a = &#x27;333&#x27;;</span></span><br><span class="line">sub1.<span class="property">a</span>.<span class="title function_">push</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sub1.<span class="property">a</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sub2.<span class="property">a</span>);</span><br><span class="line"><span class="comment">// sub1.say();</span></span><br><span class="line"><span class="comment">// sub2.say();</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>extends继承：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6支持的class语法糖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Super</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝继承</p>
</li>
<li><p>圣杯模式继承</p>
</li>
</ol>
<h3 id="33-javascript-的垃圾回收机制"><a href="#33-javascript-的垃圾回收机制" class="headerlink" title="33. javascript 的垃圾回收机制"></a>33. javascript 的垃圾回收机制</h3><p>如果没有垃圾回收机制，javascript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。由于字符串，数组，对象这些引用类型，给他们分配内存的时候是根据他们的大小进行动态分配的，动态分配的被占用的这些内存，最终都要释放掉以供再次利用。现在各个浏览器基本常采用标志清除法，和引用计数法来回收垃圾；</p>
<ol>
<li>标记清除法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当变量进入执行环境时，标记这个变量为“进入环境”；</span><br><span class="line">当变量离开环境时，标记为“离开环境”；</span><br><span class="line">垃圾回收器并不是每时每刻都在工作，每隔一段时间工作一次；</span><br><span class="line">垃圾回收器运行时，给每个变量都加上标记，然后去掉环境中的变量，以及被环境中变量引用的变量的标记。</span><br><span class="line">然后，这时候，剩下的所有的被标记的变量，都是要被清除回收的变量。</span><br><span class="line">最后，垃圾收集器销毁这些变量的值，收回占用的内存空间。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引用计数法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">跟踪每个值被引用的次数。</span><br><span class="line">当声明了一个变量，把一个引用类型的值复制给这个变量时，这个值的引用次数就是1；</span><br><span class="line">如果这个变量又重新引用了另一个值，那么原先的值引用次数就减1；</span><br><span class="line">当一个值的（被）引用次数变成0时，就说明不再也没有办法再引用这个值了。因此就可以将他的内存释放。</span><br><span class="line">垃圾收集器在下次运行时，就会回收释放掉这种引用次数为0的值的内存。</span><br><span class="line">注意会存在循环引用的问题！</span><br></pre></td></tr></table></figure>

<h3 id="34-js调bug？"><a href="#34-js调bug？" class="headerlink" title="34. js调bug？"></a>34. js调bug？</h3><ol>
<li><p>debugger：在JavaScript代码中加入一句debugger;来手工造成一个断点效果。需要带有条件的断点吗？你只需要用 if 语句包围它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (somethingHappens) &#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置在DOM node发生变化时触发断点：谷歌浏览器的开发工具里有一个超级好用的功能，专门可以对付这种情况，叫做<em>“Break on…”</em>，你在DOM节点上右键，就能看到这个菜单项。断点的触发条件可以设置成这个节点被删除、节点的属性有任何变化，或它的某个子节点有变化发生。</p>
<p><img src="/2021/06/16/%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94%20JavaScript/a5a89dde6d2a68f3d592cf6870babd6e.png"></p>
</li>
</ol>
<h3 id="35-ajax请求时get和post的区别？"><a href="#35-ajax请求时get和post的区别？" class="headerlink" title="35.ajax请求时get和post的区别？"></a>35.ajax请求时get和post的区别？</h3><p>get：从服务器上获取数据，传送数据量小，安全性低，请求会被缓存，缓存是针对URL进行缓存的，get请求参数直接加在URL地址后面，一种参数组合就会产生一种URL的缓存，重复的请求结果是相同的；、</p>
<p>post：向服务器发送数据；传送数据量大，请求不会被缓存，参数封装在二进制的数据体中，服务器也不会记录参数，相对安全，所以涉及用户隐私的数据都要用post传送；</p>
<h3 id="36-ajax请求时，如何解析json数据？"><a href="#36-ajax请求时，如何解析json数据？" class="headerlink" title="36. ajax请求时，如何解析json数据？"></a>36. ajax请求时，如何解析json数据？</h3><p>json是一种轻量级交互格式,本质上都是字符串,常用于前后端的数据交互,本质上就是字符串。</p>
<ul>
<li>前端解析后端数据：前端在解析后端发来的数据,使用JSON.parse()方法把字符串转为json对象。</li>
<li>前端向后端发送数据数据：前端在向后端发送数据,使用JSON.stringify()方法把json对象转为字符串。</li>
</ul>
<h3 id="37-跨域、同源策略以及解决跨域"><a href="#37-跨域、同源策略以及解决跨域" class="headerlink" title="37. 跨域、同源策略以及解决跨域"></a>37. 跨域、同源策略以及解决跨域</h3><p>在前端开发编码过程中，常见的html标签例如：a, form, img, script, link, iframe 以及ajax操作都可以指向一个资源地址或者说可以发起对一个资源的请求，那么这里所说的请求就存在同域请求还是跨域请求。跨域是浏览器行为，不是服务器行为。</p>
<p>出于浏览器的同源策略限制。同源策略SOP（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器很容易受到XSS、CSFR等攻击。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域。跨域原因产生：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。非同源限制：1.无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB；2.无法接触非同源网页的 DOM；3.无法向非同源地址发送 AJAX 请求。</p>
<p>跨域解决方法：</p>
<ol>
<li><p>JSONP 是服务器与客户端跨源通信的常用方法。jsonp原理就是内部会创建一个&lt;script&gt;标签，把想要请求的url加到src里，通过他的src属性进行跨域，然后把&lt;script&gt;标签动态的填加到页面上，请求发过去拿到数据之后再动态的把这个标签删除。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。核心思想：网页通过添加一个&lt;script&gt;元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。</p>
<ul>
<li>原生js实现jsonp：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;f()&quot;</span>&gt;submit&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">addScriptTag</span>(<span class="params">src</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         script.<span class="title function_">setAttribute</span>(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;text/javascript&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         script.<span class="property">src</span> = src;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">SayHi</span>(<span class="params">arg</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&quot;Hello &quot;</span>+arg)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="title function_">addScriptTag</span>(<span class="string">&quot;http://127.0.0.1:8002/get_byjsonp/?callbacks=SayHi&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">----------------------views.<span class="property">py</span></span><br><span class="line">def <span class="title function_">get_byjsonp</span>(req):</span><br><span class="line">    func=req.<span class="property">GET</span>.<span class="title function_">get</span>(<span class="string">&quot;callbacks&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">HttpResponse</span>(<span class="string">&quot;%s(&#x27;joe&#x27;)&quot;</span>%func)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>jQuery实现jsonp：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/static/jquery-2.2.3.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">url</span>:<span class="string">&quot;http://127.0.0.1:8002/get_byjsonp&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">dataType</span>:<span class="string">&quot;jsonp&quot;</span>,            <span class="comment">//必须有，告诉server，这次访问要的是一个jsonp的结果。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">jsonp</span>: <span class="string">&#x27;callbacks&#x27;</span>,          <span class="comment">//jQuery帮助随机生成的：callbacks=&quot;wner&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(data)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">#-------------------------------------<span class="attr">http</span>:<span class="comment">//127.0.0.1:8002/get_byjsonp</span></span><br><span class="line">def <span class="title function_">get_byjsonp</span>(req):</span><br><span class="line">    callbacks=req.<span class="property">GET</span>.<span class="title function_">get</span>(<span class="string">&#x27;callbacks&#x27;</span>)</span><br><span class="line">    <span class="title function_">print</span>(callbacks)                 #wner  </span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">HttpResponse</span>(<span class="string">&quot;%s(&#x27;joe&#x27;)&quot;</span>%callbacks)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CORS 是跨域资源共享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request），对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</p>
<p>1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin &#x3D; ‘指定域名’；</p>
<p>2、带cookie跨域请求：前后端都需要进行设置。服务器端设置 Access-Control-Allow-Credentials: true，在AJAX请求中打开 withCredentials 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用nginx反向代理：Nginx 反向代理模块 proxy_pass，proxy_pass 后面跟着一个 URL，用来将请求反向代理到 URL 参数指定的服务器上。例如 proxy_pass <a target="_blank" rel="noopener" href="https://api.shanbay.com,则将匹配的请求反向代理到/">https://api.shanbay.com，则将匹配的请求反向代理到</a> <a target="_blank" rel="noopener" href="https://api.shanbay.com.通过在配置文件中增加proxy_pass/">https://api.shanbay.com。通过在配置文件中增加proxy_pass</a> 你的服务器ip,例如这里的扇贝服务器地址，就可以完成反向代理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    ## 用户访问 localhost，则反向代理到<span class="attr">https</span>:<span class="comment">//api.shanbay.com</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        proxy_pass <span class="attr">https</span>:<span class="comment">//api.shanbay.com;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理服务器，客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据，存放在代理服务器的硬盘中，再发送给客户机。反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。</p>
<ul>
<li>正向代理，架设在客户机与目标主机之间，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。隐藏了真实的客户端。</li>
<li>反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器与目标主机一起对外表现为一个服务器。隐藏了真实的服务器。</li>
</ul>
</li>
</ol>
<h3 id="38-scrollWidth、clientWidth、offsetWidth、innerWidth-区别"><a href="#38-scrollWidth、clientWidth、offsetWidth、innerWidth-区别" class="headerlink" title="38. scrollWidth、clientWidth、offsetWidth、innerWidth 区别"></a>38. scrollWidth、clientWidth、offsetWidth、innerWidth 区别</h3><ul>
<li>scrollWidth ：是对象的实际内容的宽，不包含边线宽度，会随对象中内容的多少改变（内容多了可能会改变对象的实际宽度）。 </li>
<li>clientWidth ：对象内容的可视区的宽度，不包滚动条等边线，会随对象显示大小的变化而改变。 </li>
<li>offsetWidth ：对象整体的实际宽度，包滚动条等边线，会随对象显示大小的变化而改变。</li>
<li>innerWidth：window.innerWidth&#x3D;浏览器窗口的内部宽度；window.innerHeight&#x3D;浏览器窗口的内部高度。</li>
</ul>
<h3 id="39-promise和async-x2F-await"><a href="#39-promise和async-x2F-await" class="headerlink" title="39. promise和async&#x2F;await"></a>39. promise和async&#x2F;await</h3><p>为了解决Callback hell回调地狱，promise和async&#x2F;await诞生。</p>
<ul>
<li><p>promise的作用是对异步回调代码包装一下，把原来的一个回调函数拆成2个回调函数，这样的好处是可读性更好。语法如下：</p>
<p>注意：Promise内部的resolve和reject方法只能调用一次，调用了这个就不能再调用那个了；如果调用，则无效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用promise对含有回调方法的代码进行包装</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve方法是当异步操作成功时候调用</span></span><br><span class="line">    <span class="comment">// reject方法是当异步操作出现异常时调用</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&quot;test/a.txt&quot;</span>, <span class="function">(<span class="params">err, data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">// 说明有异常</span></span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 说明异步操作是成功的</span></span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 直接使用promise，问题是仍然需要传回调，不建议直接使用</span></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;异步操作成功&quot;</span> + data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出异常&quot;</span> + err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>async&#x2F;await的作用是直接将Promise异步代码变为同步的写法，注意，代码仍然是异步的。</p>
<p>语法要求：</p>
<ul>
<li>await只能用在async修饰的方法中，但是有async不要求一定有await。</li>
<li>await后面只能跟async方法和promise。</li>
</ul>
<p>假设拥有了一个promise对象，现在使用async&#x2F;await可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用async/await语法来调用promise对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 使用try/catch捕获promise内部的异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">await</span> promise;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise内部出异常了：&quot;</span> +e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">asyncDemo</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="40-async-x2F-await-和-Promise的区别？"><a href="#40-async-x2F-await-和-Promise的区别？" class="headerlink" title="40. async&#x2F;await 和 Promise的区别？"></a>40. async&#x2F;await 和 Promise的区别？</h3><ol>
<li>async&#x2F;await是写异步代码的新方式，以前的方法有回调函数和Promise。</li>
<li>async&#x2F;await是基于Promise实现的，它不能用于普通的回调函数。</li>
<li>async&#x2F;await与Promise一样，是非阻塞的。</li>
<li>async&#x2F;await使得异步代码看起来像同步代码，这正是它的魔力所在。</li>
</ol>
<h3 id="41-forEach-和-map的区别"><a href="#41-forEach-和-map的区别" class="headerlink" title="41. forEach 和 map的区别"></a>41. forEach 和 map的区别</h3><ul>
<li>foreEach() 方法: 针对每一个元素执行提供的函数。</li>
<li>map() 方法: 创建一个新的数组，其中每一个元素由调用数组中的每一个元素执行提供的函数得来。</li>
</ul>
<p>区别：forEach() 方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。</p>
<h3 id="42-防抖和节流"><a href="#42-防抖和节流" class="headerlink" title="42. 防抖和节流"></a>42. 防抖和节流</h3><p>防抖：事件响应函数(doSomeThing)在一段时间后(300ms)才执行，如果在这段时间再次调用，则重新计算执行时间；当预定的时间内没有再次调用该函数，则执行事件响应函数doSomeThing。</p>
<p>应用场景：</p>
<ol>
<li>scroll事件滚动触发；</li>
<li>搜索框输入验证；</li>
<li>表单验证；</li>
<li>按钮提交事件；</li>
<li>浏览器窗口缩放，resize事件；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="comment">// 缺点：函数的 this 指向了 window，应该指向 container</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce1</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二版（解决this指向问题）</span></span><br><span class="line"><span class="comment">// 缺点：函数的事件对象 event 变成了 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce2</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="comment">// console.log(this);  // 这里的 this 是对的</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">call</span>(<span class="variable language_">this</span>)    <span class="comment">//绑定上面的 this</span></span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三版（解决 event 事件对象问题）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce3</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)   <span class="comment">// 把参数传进去</span></span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四版（immediate参数为true或false的情况）</span></span><br><span class="line"><span class="comment">// immediate为true就是第一次会先直接执行一次，刚开始timer为undefined，callNow为true就立即执行；接着在wait时间内一直操作，timer就是有值的，callNow为false就不执行；等停止操作wait时间后，timer被赋为null了，这下再操作又会立即执行。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce4</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timer;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="comment">// 立即执行</span></span><br><span class="line">            <span class="keyword">if</span> (callNow) func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.<span class="property">onmousemove</span> = <span class="title function_">debounce4</span>(doSomeThing,<span class="number">2000</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>节流：如果持续触发事件，每隔一段时间，只执行一次事件。在规定时间内，保证执行一次该函数。</p>
<p>应用场景：</p>
<ol>
<li>DOM元素的拖拽功能实现；</li>
<li>射击游戏；</li>
<li>计算鼠标移动的距离；</li>
<li>监听scroll滚动事件；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用时间戳实现节流：第一次触发，最后一次不会触发</span></span><br><span class="line"><span class="comment">// 顾头不顾尾</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle1</span>(<span class="params">func,wait</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> context,args;</span><br><span class="line">    <span class="comment">// 之前的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> old = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>();</span><br><span class="line">        <span class="keyword">if</span>(now-old &gt; wait)&#123;</span><br><span class="line">            <span class="comment">// 立即执行</span></span><br><span class="line">            func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">            old = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用定时器：第一次不会触发，最后一次会触发</span></span><br><span class="line"><span class="comment">// 不顾头顾尾</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle2</span>(<span class="params">func,wait</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> context,args,timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(!timeout)&#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳+定时器：第一次会执行，最后一次还会执行</span></span><br><span class="line"><span class="comment">// 顾头又顾尾</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle3</span>(<span class="params">func,wait</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">let</span> old = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>();</span><br><span class="line">        <span class="keyword">if</span>(now-old &gt; wait)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">            old = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">                old = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>();</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码稍微写好看点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle3</span>(<span class="params">func,wait</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> context,args,timeout;</span><br><span class="line">    <span class="keyword">let</span> old = <span class="number">0</span>;   <span class="comment">// 时间戳</span></span><br><span class="line">    <span class="keyword">let</span> later = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        old = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>();</span><br><span class="line">        <span class="keyword">if</span>(now-old &gt; wait)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">            old = now;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!timeout)&#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(later,wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流完整版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle4</span>(<span class="params">func,wait,options</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">let</span> old = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!options) options = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>();</span><br><span class="line">        <span class="keyword">if</span>(options.<span class="property">leading</span> === <span class="literal">false</span> &amp;&amp; !old)&#123;</span><br><span class="line">            old = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-old &gt; wait)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">            old = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!timer &amp;&amp; options.<span class="property">trailing</span> !== <span class="literal">false</span>)&#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                old = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>();</span><br><span class="line">                func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码稍微写好看点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle4</span>(<span class="params">func,wait,options</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> context,args,timeout;</span><br><span class="line">    <span class="keyword">let</span> old = <span class="number">0</span>;   <span class="comment">// 时间戳</span></span><br><span class="line">    <span class="keyword">if</span>(!options)&#123;options = &#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">let</span> later = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        old = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>();</span><br><span class="line">        <span class="keyword">if</span>(options.<span class="property">leading</span> === <span class="literal">false</span> &amp;&amp; !old)&#123;</span><br><span class="line">            old = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-old &gt; wait)&#123;</span><br><span class="line">            <span class="comment">// 第一次会直接执行</span></span><br><span class="line">            <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            func.<span class="title function_">apply</span>(context,args);</span><br><span class="line">            old = now;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!timeout &amp;&amp; options.<span class="property">trailing</span> !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">// 最后一次会执行</span></span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(later,wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.<span class="property">onmousemove</span> = <span class="title function_">throttle4</span>(doSomeThing,<span class="number">2000</span>,&#123;</span><br><span class="line">    <span class="attr">leading</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">trailing</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="43-js中-x3D-x3D-和-x3D-x3D-x3D-的区别？"><a href="#43-js中-x3D-x3D-和-x3D-x3D-x3D-的区别？" class="headerlink" title="43. js中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别？"></a>43. js中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别？</h3><p>双等号 =&#x3D;： 可转换类型再比较</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）如果两个值类型相同，再进行三个等号(===)的比较；</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</span><br><span class="line">　　　　<span class="number">1</span>）如果一个是<span class="literal">null</span>，一个是<span class="literal">undefined</span>，那么相等；</span><br><span class="line">　　　　<span class="number">2</span>）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较；</span><br></pre></td></tr></table></figure>

<p>三等号 =&#x3D;&#x3D;：不能转换类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）如果类型不同，就一定不相等；</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是<span class="title class_">NaN</span>，那么不相等。（判断一个值是否是<span class="title class_">NaN</span>，只能使用<span class="built_in">isNaN</span>( ) 来判断）；</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）如果两个值都是<span class="literal">true</span>，或是<span class="literal">false</span>，那么相等；</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）如果两个值都引用同一个对象或是函数，那么相等，否则不相等；</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）如果两个值都是<span class="literal">null</span>，或是<span class="literal">undefined</span>，那么相等；</span><br></pre></td></tr></table></figure>

<h3 id="44-弹出输入框"><a href="#44-弹出输入框" class="headerlink" title="44. 弹出输入框"></a>44. 弹出输入框</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;disp_prompt()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">disp_prompt</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">	        <span class="keyword">var</span> name = <span class="title function_">prompt</span>(<span class="string">&quot;请输入您的名字&quot;</span>,<span class="string">&quot;&quot;</span>); <span class="comment">// 弹出input框</span></span></span><br><span class="line"><span class="language-javascript">	        <span class="title function_">alert</span>(<span class="string">&quot;您的名字是：&quot;</span>+name);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="45-js函数调用时传递的隐式参数"><a href="#45-js函数调用时传递的隐式参数" class="headerlink" title="45. js函数调用时传递的隐式参数"></a>45. js函数调用时传递的隐式参数</h3><p>在函数调用的时候，浏览器每次都会传递进两个隐式参数：</p>
<ol>
<li><p>函数的上下文对象this；</p>
</li>
<li><p>封装实参的对象arguments；</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);   <span class="comment">// 打印出的arguments见下</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(<span class="string">&#x27;Tom&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],&#123;<span class="attr">name</span>:<span class="string">&#x27;Jerry&#x27;</span>&#125;); </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Arguments</span>(<span class="number">3</span>) [<span class="string">&quot;Tom&quot;</span>, <span class="title class_">Array</span>(<span class="number">3</span>), &#123;…&#125;, <span class="attr">callee</span>: ƒ, <span class="title class_">Symbol</span>(<span class="title class_">Symbol</span>.<span class="property">iterator</span>): ƒ]</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    <span class="number">1</span>: (<span class="number">3</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="number">2</span>: &#123;<span class="attr">name</span>: <span class="string">&quot;Jerry&quot;</span>&#125;</span><br><span class="line">    <span class="attr">callee</span>: ƒ <span class="title function_">fun</span>()</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">    <span class="title class_">Symbol</span>(<span class="title class_">Symbol</span>.<span class="property">iterator</span>): ƒ <span class="title function_">values</span>()</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br></pre></td></tr></table></figure>






<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>以上为个人学习笔记总结，参考了许多网上大神的文章，供大家学习参考交流，如有版权问题请联系我，侵删。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">JoeXu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dr_BigJoe/article/details/108261290">https://blog.csdn.net/Dr_BigJoe/article/details/108261290</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">以上为个人学习笔记总结，供学习参考交流，转载请注明出处。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/67886383?s=400&amp;u=99fc4b7b2788d8823a12f2924f7942669b39b105&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/16/%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94%20%E5%85%B6%E4%BB%96/" title="【2021届前端面试】— 其他"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">【2021届前端面试】— 其他</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/03/%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94%20HTML&amp;CSS/" title="【2021届前端面试】— HTML&amp;CSS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">【2021届前端面试】— HTML&amp;CSS</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/05/03/%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94%20HTML&CSS/" title="【2021届前端面试】— HTML&amp;CSS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-03</div><div class="title">【2021届前端面试】— HTML&amp;CSS</div></div></a></div><div><a href="/2021/06/16/%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94%20%E5%85%B6%E4%BB%96/" title="【2021届前端面试】— 其他"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-16</div><div class="title">【2021届前端面试】— 其他</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/67886383?s=400&amp;u=99fc4b7b2788d8823a12f2924f7942669b39b105&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Joe Xu</div><div class="author-info__description">Stay hungry, Stay Foolish</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JoeXu727" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%902021%E5%B1%8A%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E2%80%94-JavaScript"><span class="toc-number">1.</span> <span class="toc-text">【2021届前端面试】— JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ES6%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. ES6的新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ES6-%E7%9A%84-class-%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. ES6 的 class 和构造函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JS%E7%9A%84%E4%B8%89%E5%A4%A7%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. JS的三大事件是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-js%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. js判断是不是数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%EF%BC%8Cslice-%E3%80%81splice-%E3%80%81substring-%E3%80%81substr-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.5.</span> <span class="toc-text">5. js数组常用的操作方法，slice()、splice()、substring()、substr()区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-JavaScript-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%EF%BC%88%E6%95%B0%E7%BB%84%E6%88%96%E5%AF%B9%E8%B1%A1%EF%BC%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.6.</span> <span class="toc-text">6. JavaScript 中的常用循环遍历（数组或对象）的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.0.7.</span> <span class="toc-text">7. js数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-js%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">1.0.8.</span> <span class="toc-text">8. js数组扁平化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-js%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F"><span class="toc-number">1.0.9.</span> <span class="toc-text">9. js数组乱序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-js%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">1.0.10.</span> <span class="toc-text">10. js函数柯里化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-js%E6%95%B0%E7%BB%84%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.0.11.</span> <span class="toc-text">11. js数组的合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.0.12.</span> <span class="toc-text">12. js对象的合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-let-var-const%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.13.</span> <span class="toc-text">13. let var const区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-JS%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.14.</span> <span class="toc-text">14. JS强制类型转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Parseint-%E3%80%81Math-round-%E3%80%81Math-floor-%E3%80%81Math-ceil-%E5%9B%9B%E7%A7%8D%E5%8F%96%E6%95%B4%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.15.</span> <span class="toc-text">15. Parseint()、Math.round()、Math.floor()、Math.ceil()四种取整方法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.16.</span> <span class="toc-text">16. null和undefined的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-JS%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.0.17.</span> <span class="toc-text">17. JS深浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-JS%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.0.18.</span> <span class="toc-text">18. JS闭包的概念？优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-js-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E3%80%81%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.19.</span> <span class="toc-text">19. js 执行机制、事件循环、异步编程方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%EF%BC%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84this%EF%BC%8C%E6%80%8E%E4%B9%88%E6%94%B9%E5%8F%98%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E7%9A%84this%E6%8C%87%E5%90%91%EF%BC%9F"><span class="toc-number">1.0.20.</span> <span class="toc-text">20. this的指向问题，普通函数和箭头函数的this，怎么改变普通函数里面的this指向？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.21.</span> <span class="toc-text">21. call和apply的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-apply%E3%80%81call%E3%80%81bind%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%94%A8apply%E5%AE%9E%E7%8E%B0bind%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.0.22.</span> <span class="toc-text">22. apply、call、bind区别？以及如何用apply实现bind函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-DOM-%E4%BA%8B%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E9%98%B6%E6%AE%B5-%E4%BA%8B%E4%BB%B6%E6%B5%81-%EF%BC%9F%E8%B0%88%E8%B0%88%E5%AF%B9%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86-x2F-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.0.23.</span> <span class="toc-text">23. DOM 事件有哪些阶段(事件流)？谈谈对事件代理&#x2F;事件委托的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%B8%80%E4%B8%AADOM%E5%85%83%E7%B4%A0%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E4%BA%8B%E4%BB%B6%E6%97%B6%EF%BC%8C%E5%85%88%E6%89%A7%E8%A1%8C%E5%86%92%E6%B3%A1%E8%BF%98%E6%98%AF%E6%8D%95%E8%8E%B7%EF%BC%9F"><span class="toc-number">1.0.24.</span> <span class="toc-text">24. 一个DOM元素绑定多个事件时，先执行冒泡还是捕获？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-DOM%E4%BA%8B%E4%BB%B6event%E5%AF%B9%E8%B1%A1%E4%B8%ADtarget%E5%92%8CcurrentTarget%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.25.</span> <span class="toc-text">25. DOM事件event对象中target和currentTarget的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-JS%E4%B8%ADDOM%E4%BA%8B%E4%BB%B6%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.26.</span> <span class="toc-text">26. JS中DOM事件中一些常见的浏览器兼容问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-JavaScript%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.27.</span> <span class="toc-text">27. JavaScript绑定事件的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-jQuery%E4%B8%AD%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6on%E5%92%8Cbind%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.28.</span> <span class="toc-text">28. jQuery中绑定事件on和bind的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-js%E5%8E%9F%E5%9E%8B%E9%93%BE-https-www-cnblogs-com-jzhey-p-12582506-html"><span class="toc-number">1.0.29.</span> <span class="toc-text">29. js原型链 (https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jzhey&#x2F;p&#x2F;12582506.html)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.30.</span> <span class="toc-text">30. 原型对象和构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-js-new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.31.</span> <span class="toc-text">31. js new一个对象的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-js%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.0.32.</span> <span class="toc-text">32. js继承的几种方式及优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-javascript-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.33.</span> <span class="toc-text">33. javascript 的垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-js%E8%B0%83bug%EF%BC%9F"><span class="toc-number">1.0.34.</span> <span class="toc-text">34. js调bug？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-ajax%E8%AF%B7%E6%B1%82%E6%97%B6get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.35.</span> <span class="toc-text">35.ajax请求时get和post的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-ajax%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90json%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">1.0.36.</span> <span class="toc-text">36. ajax请求时，如何解析json数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E8%B7%A8%E5%9F%9F%E3%80%81%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-number">1.0.37.</span> <span class="toc-text">37. 跨域、同源策略以及解决跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-scrollWidth%E3%80%81clientWidth%E3%80%81offsetWidth%E3%80%81innerWidth-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.38.</span> <span class="toc-text">38. scrollWidth、clientWidth、offsetWidth、innerWidth 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-promise%E5%92%8Casync-x2F-await"><span class="toc-number">1.0.39.</span> <span class="toc-text">39. promise和async&#x2F;await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-async-x2F-await-%E5%92%8C-Promise%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.40.</span> <span class="toc-text">40. async&#x2F;await 和 Promise的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-forEach-%E5%92%8C-map%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.41.</span> <span class="toc-text">41. forEach 和 map的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">1.0.42.</span> <span class="toc-text">42. 防抖和节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-js%E4%B8%AD-x3D-x3D-%E5%92%8C-x3D-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.43.</span> <span class="toc-text">43. js中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E5%BC%B9%E5%87%BA%E8%BE%93%E5%85%A5%E6%A1%86"><span class="toc-number">1.0.44.</span> <span class="toc-text">44. 弹出输入框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-js%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E4%BC%A0%E9%80%92%E7%9A%84%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.45.</span> <span class="toc-text">45. js函数调用时传递的隐式参数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/03/%E3%80%90%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF%E3%80%91%E2%80%94%20%E8%A7%A3%E5%86%B3GitHub%20push%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99403/" title="【踩坑之路】— 解决GitHub push代码报错403">【踩坑之路】— 解决GitHub push代码报错403</a><time datetime="2024-03-03T12:24:30.000Z" title="Created 2024-03-03 20:24:30">2024-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/02/%E3%80%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%95%E6%93%8E%E5%AE%9E%E6%88%98%E3%80%91%E2%80%94%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%A9%E6%96%99%E6%8E%A5%E5%85%A5demo(%E5%86%85%E5%90%ABnpm%E5%8F%91%E5%8C%85%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4)/" title="【阿里低代码引擎实战】— 自定义物料接入demo(内含npm发包详细步骤)">【阿里低代码引擎实战】— 自定义物料接入demo(内含npm发包详细步骤)</a><time datetime="2024-03-02T03:03:30.000Z" title="Created 2024-03-02 11:03:30">2024-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/24/%E3%80%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%95%E6%93%8E%E5%AE%9E%E6%88%98%E3%80%91%E2%80%94%20%E5%AE%89%E8%A3%85WSL%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE/" title="【阿里低代码引擎实战】— 安装WSL与初始化项目">【阿里低代码引擎实战】— 安装WSL与初始化项目</a><time datetime="2024-02-24T02:35:02.000Z" title="Created 2024-02-24 10:35:02">2024-02-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/24/%E3%80%90%E5%89%8D%E7%AB%AF%E8%8F%9C%E9%B8%A1%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF%E3%80%91%E2%80%94%20Vue3%20getCurrentInstance%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%BAtext/" title="【前端菜鸡踩坑之路】— Vue3 getCurrentInstance获取到的节点为text">【前端菜鸡踩坑之路】— Vue3 getCurrentInstance获取到的节点为text</a><time datetime="2023-12-24T03:47:18.000Z" title="Created 2023-12-24 11:47:18">2023-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/31/%E3%80%90%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E6%87%82%E6%BA%90%E7%A0%81%E3%80%91%E2%80%94%20Ant%20design%20vue%E6%BA%90%E7%A0%81%E4%B9%8BTransfer%E7%A9%BF%E6%A2%AD%E6%A0%91/" title="【小白也能懂源码】— Ant design vue源码之Transfer穿梭树">【小白也能懂源码】— Ant design vue源码之Transfer穿梭树</a><time datetime="2023-07-31T07:18:18.000Z" title="Created 2023-07-31 15:18:18">2023-07-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Joe Xu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
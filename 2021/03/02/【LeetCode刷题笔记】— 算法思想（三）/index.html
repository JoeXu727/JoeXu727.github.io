<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>【LeetCode刷题笔记】— 算法思想（三） | Debug the World</title><meta name="author" content="Joe Xu"><meta name="copyright" content="Joe Xu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【LeetCode刷题笔记】— 算法思想（三）五、分治241. 为运算表达式设计优先级给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 示例 1: 输入: &quot;2-1-1&quot; 输出: [0, 2] 解释:  ((2-1)-1) &#x3D; 0  (2-(1-1)) &#x3D; 2  示例">
<meta property="og:type" content="article">
<meta property="og:title" content="【LeetCode刷题笔记】— 算法思想（三）">
<meta property="og:url" content="http://example.com/2021/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89/index.html">
<meta property="og:site_name" content="Debug the World">
<meta property="og:description" content="【LeetCode刷题笔记】— 算法思想（三）五、分治241. 为运算表达式设计优先级给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 示例 1: 输入: &quot;2-1-1&quot; 输出: [0, 2] 解释:  ((2-1)-1) &#x3D; 0  (2-(1-1)) &#x3D; 2  示例">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/67886383?s=400&u=99fc4b7b2788d8823a12f2924f7942669b39b105&v=4">
<meta property="article:published_time" content="2021-03-02T10:36:44.000Z">
<meta property="article:modified_time" content="2023-04-09T03:20:34.440Z">
<meta property="article:author" content="Joe Xu">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/67886383?s=400&u=99fc4b7b2788d8823a12f2924f7942669b39b105&v=4"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":288},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【LeetCode刷题笔记】— 算法思想（三）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-09 11:20:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/67886383?s=400&amp;u=99fc4b7b2788d8823a12f2924f7942669b39b105&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Debug the World"><span class="site-name">Debug the World</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【LeetCode刷题笔记】— 算法思想（三）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-03-02T10:36:44.000Z" title="Created 2021-03-02 18:36:44">2021-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-04-09T03:20:34.440Z" title="Updated 2023-04-09 11:20:34">2023-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【LeetCode刷题笔记】— 算法思想（三）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="【LeetCode刷题笔记】—-算法思想（三）"><a href="#【LeetCode刷题笔记】—-算法思想（三）" class="headerlink" title="【LeetCode刷题笔记】— 算法思想（三）"></a>【LeetCode刷题笔记】— 算法思想（三）</h1><h2 id="五、分治"><a href="#五、分治" class="headerlink" title="五、分治"></a>五、分治</h2><h3 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241. 为运算表达式设计优先级"></a>241. 为运算表达式设计优先级</h3><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;2-1-1&quot;
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
</code></pre>
<p>示例 2:</p>
<pre><code>输入: &quot;2*3-4*5&quot;
输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
</code></pre>
<p><strong>思路：</strong> 以运算符作为分隔，递归的求解左右两侧的算式。利用分治思想三步走：1.分解：按运算符分成左右两部分，分别求解；2.解决：实现一个递归函数，输入算式，返回算式解；3.合并：根据运算符，合并左右两部分的解，得出最终解。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():   <span class="comment"># 如果只有数字，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> index, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 1.分解：遇到运算符，计算左右两侧的结果集</span></span><br><span class="line">                <span class="comment"># 2.解决：diffWaysToCompute 递归函数求出子问题的解</span></span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:index])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[index+<span class="number">1</span>:])</span><br><span class="line">                <span class="comment"># 3.合并：根据运算符，合并子问题的解</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            res.append(<span class="built_in">int</span>(l) + <span class="built_in">int</span>(r))  <span class="comment"># py3 input类型默认是字符串</span></span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            res.append(<span class="built_in">int</span>(l) - <span class="built_in">int</span>(r))</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                            res.append(<span class="built_in">int</span>(l) * <span class="built_in">int</span>(r))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h3><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<pre><code>输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</code></pre>
<p><strong>思路：</strong> 使用动态规划。假设n个节点存在G(n)个不同的二叉搜索树，遍历每个节点，以每个节点为根构建二叉搜索树，令 f(i) 为以i为根的二叉搜索树的个数，则：G(n) &#x3D; f(1) + f(2) + f(3) + … + f(n)。例如当n&#x3D;7，[1,2,3,4,5,6,7]时，假设 i&#x3D;3 为根节点，其左子树节点个数为2个，其右子树节点个数为4个，可表示为：f(i) &#x3D; G(2) * G(4)，写成通式则为：f(i) &#x3D; G(i-1) * G(n-i)。综合上面两个公式可得著名的<strong>卡特兰数</strong>公式：G(n) &#x3D; G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)。对于本题，dp[0]和dp[1]很容易得到均为1，根据动态规划递推式可得dp[n]的值。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>   <span class="comment"># 空二叉树也算一种</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>   <span class="comment"># 一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>] * dp[i-j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a>95. 不同的二叉搜索树 II</h3><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<p>示例：</p>
<pre><code>输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</code></pre>
<p>提示：  0 &lt;&#x3D; n &lt;&#x3D; 8</p>
<p><strong>思路：</strong> 根据96题的思路，首先定义一个用于生成树的函数build_Trees(left, right)，表示生成 [left,…,right]的所有可能二叉搜索树。若left &gt; right，说明为空树，返回None；遍历每个节点，递归的生成左右子树，所有可能的左子树列表 left_trees &#x3D; build_Trees(left, i-1)；所有可能的右子树列表 right_trees &#x3D; build_Trees(i+1, right)，用两层循环组合左右子树，生成二叉搜索树。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">build_Trees</span>(<span class="params">left, right</span>):</span><br><span class="line">            all_trees = []</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right):  <span class="comment"># 说明是空树</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                left_trees = build_Trees(left, i - <span class="number">1</span>)</span><br><span class="line">                right_trees = build_Trees(i + <span class="number">1</span>, right)</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left_trees:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right_trees:</span><br><span class="line">                        cur_tree = TreeNode(i)</span><br><span class="line">                        cur_tree.left = l</span><br><span class="line">                        cur_tree.right = r</span><br><span class="line">                        all_trees.append(cur_tree)</span><br><span class="line">            <span class="keyword">return</span> all_trees</span><br><span class="line"></span><br><span class="line">        res = build_Trees(<span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="六、搜索"><a href="#六、搜索" class="headerlink" title="六、搜索"></a>六、搜索</h2><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a>1091. 二进制矩阵中的最短路径</h3><p>在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。</p>
<p>一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, …, C_k 组成：</p>
<pre><code>相邻单元格 C_i 和 C_&#123;i+1&#125; 在八个方向之一上连通（此时，C_i 和 C_&#123;i+1&#125; 不同且共享边或角）
C_1 位于 (0, 0)（即，值为 grid[0][0]）
C_k 位于 (N-1, N-1)（即，值为 grid[N-1][N-1]）
如果 C_i 位于 (r, c)，则 grid[r][c] 为空（即，grid[r][c] == 0）
</code></pre>
<p>返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。</p>
<p>示例 1：</p>
<pre><code>输入：[[0,1],[1,0]]

输出：2
</code></pre>
<p>示例 2：</p>
<pre><code>输入：[[0,0,0],[1,1,0],[1,1,0]]

输出：4
</code></pre>
<p>提示：</p>
<pre><code>1 &lt;= grid.length == grid[0].length &lt;= 100
grid[i][j] 为 0 或 1
</code></pre>
<p><strong>思路：</strong> 使用广度优先搜索BFS，把要搜索的点加入队列，对每层进行遍历判断，每个点都向8个方向进行扩展，探索通路，新的通路的点再加入队列，直到走到终点。BFS中，最先到达终点的就是最短路径，每一层遍历的节点都与根节点距离相同。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestPathBinaryMatrix</span>(<span class="params">self, grid</span>):</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 起点或终点是堵塞状态，没有路</span></span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">or</span> grid[<span class="built_in">len</span>(grid)-<span class="number">1</span>][<span class="built_in">len</span>(grid)-<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        res = <span class="number">1</span>   <span class="comment"># res代表路径长度</span></span><br><span class="line">        path = deque()</span><br><span class="line">        path.append([<span class="number">0</span>,<span class="number">0</span>])   <span class="comment"># 先把起点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> path:  <span class="comment"># BFS广度优先搜索</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path)):  <span class="comment"># 对BFS的某一层的中所有点向8个方向进行扩展</span></span><br><span class="line">                x, y = path.popleft()</span><br><span class="line">                <span class="keyword">for</span> new_x, new_y <span class="keyword">in</span> [(x-<span class="number">1</span>, y-<span class="number">1</span>),(x, y-<span class="number">1</span>),(x+<span class="number">1</span>, y-<span class="number">1</span>),(x+<span class="number">1</span>, y),</span><br><span class="line">                    (x+<span class="number">1</span>, y+<span class="number">1</span>),(x, y+<span class="number">1</span>),(x-<span class="number">1</span>, y+<span class="number">1</span>),(x-<span class="number">1</span>, y)]:</span><br><span class="line">                    <span class="keyword">if</span> new_x == <span class="built_in">len</span>(grid)-<span class="number">1</span> <span class="keyword">and</span> new_y == <span class="built_in">len</span>(grid)-<span class="number">1</span>: <span class="comment"># 若走到了终点</span></span><br><span class="line">                        <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> new_x &lt; <span class="number">0</span> <span class="keyword">or</span> new_x &gt; <span class="built_in">len</span>(grid)-<span class="number">1</span> <span class="keyword">or</span> new_y &lt; <span class="number">0</span> <span class="keyword">or</span> new_y &gt; <span class="built_in">len</span>(grid)-<span class="number">1</span>: <span class="comment"># 扩展的点超出边界</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">1</span> <span class="keyword">or</span> grid[new_x][new_y] == -<span class="number">1</span>: <span class="comment"># 扩展的点为阻塞或已经访问过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">0</span>:  <span class="comment"># 扩展的点是通路</span></span><br><span class="line">                        grid[new_x][new_y] = -<span class="number">1</span>  <span class="comment"># 将该点设置成已访问</span></span><br><span class="line">                        path.append([new_x,new_y])  <span class="comment"># 将该点加入队列</span></span><br><span class="line">            res += <span class="number">1</span> <span class="comment"># 对某一层的元素都判定后，距离加1(同一个层中所有点距起点距离相等）</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h3><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<pre><code>输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
</code></pre>
<p>示例 2:</p>
<pre><code>输入: n = 13
输出: 2
解释: 13 = 4 + 9.
</code></pre>
<p><strong>思路：</strong><br><img src="/2021/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89/20200603210749644.png" alt="在这里插入图片描述"><br>本题可以转化为BFS思路，使用广度优先遍历顺序遍历每一行，所以当节点差出现0时，此时一定是最短的路径。如绿色所示，若此时节点为0，表示根节点可以由路径上的平方数{1,1,9}构成，返回此时的路径长度为3，后续不再执行。如红色所示，若节点值在之前已经出现，则不需要再计算，一定不会比最短路径短，最短路径还未出现。实现广度优先搜索一般都需要借助队列，循环遍历，每次计算 x &#x3D; num - i^2，i 的范围是[1, int(num**0.5)+1)。若x&#x3D;&#x3D;0说明找到了路径；若x不在visited里说明当前节点未出现过，将该节点假如visited并加入队列。</p>
<p>此题另一种解法见：动态规划 -&gt; 分割整数 -&gt; 279. 完全平方数。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(n)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                num = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(num**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">                    x = num - i*i</span><br><span class="line">                    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> step</span><br><span class="line">                    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(x)</span><br><span class="line">                        queue.append(x)</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure>


<h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a>127. 单词接龙</h3><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<pre><code>每次转换只能改变一个字母。
转换过程中的中间单词必须是字典中的单词。
</code></pre>
<p>说明:</p>
<pre><code>如果不存在这样的转换序列，返回 0。
所有单词具有相同的长度。
所有单词只由小写字母组成。
字典中不存在重复的单词。
你可以假设 beginWord 和 endWord 是非空的，且二者不相同。
</code></pre>
<p>示例 1:</p>
<pre><code>输入:
beginWord = &quot;hit&quot;,
endWord = &quot;cog&quot;,
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]

输出: 5

解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,
     返回它的长度 5。
</code></pre>
<p>示例 2:</p>
<pre><code>输入:
beginWord = &quot;hit&quot;
endWord = &quot;cog&quot;
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]

输出: 0

解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。
</code></pre>
<p><strong>思路：</strong><br><img src="/2021/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89/20200603210953892.png" alt="在这里插入图片描述"><br>单词接龙问题可以把每个单词看作节点，差距只有一个字母的两个单词连成一条边，问题变成找到从起点到终点的最短路径，使用广度优先搜索BFS。其中最重要的步骤是找到相邻的节点，也就是只差一个字母的单词，我们可以将wordlist中单词处理成通用状态，将单词中的某个字母用_代替例如：hot 有三个通用状态分别是：_ot, h_t, ho_。通过遍历每个单词的所有通用状态，并在字典里找到并遍历该通用状态对应的所有单词，字典里对应的这些单词都和当前单词有同样的通用状态，所以是当前单词的相邻节点，同时也处于BFS中当前节点的下一层。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList</span>):</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(beginWord)  <span class="comment"># 所有单词具有相同长度</span></span><br><span class="line">        all_combo_dict = defaultdict(<span class="built_in">list</span>)  <span class="comment"># defaultdict(list)构建一个默认值为list的字典</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:   <span class="comment"># 对wordList中的单词做预处理</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                <span class="comment"># 字典的键是通用状态，例如：d*g</span></span><br><span class="line">                <span class="comment"># 字典的值是一个列表，里面存着拥有相同通用状态的所有单词</span></span><br><span class="line">                all_combo_dict[word[:i] + <span class="string">&quot;*&quot;</span> + word[i+<span class="number">1</span>:]].append(word)</span><br><span class="line"></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append([beginWord,<span class="number">1</span>])</span><br><span class="line">        visited = &#123;beginWord: <span class="literal">True</span>&#125;   <span class="comment"># Visited 确保不会重复处理同一个单词</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current_word, level = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                intermediate_word = current_word[:i] + <span class="string">&quot;*&quot;</span> + current_word[i + <span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> all_combo_dict[intermediate_word]:</span><br><span class="line">                    <span class="keyword">if</span> word == endWord:</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited[word] = <span class="literal">True</span>  <span class="comment"># 该单词标记为已访问</span></span><br><span class="line">                        queue.append((word, level+<span class="number">1</span>))</span><br><span class="line">                all_combo_dict[intermediate_word] = []</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h3><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p>
<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p>
<p>示例 1:</p>
<pre><code>[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]

对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。
</code></pre>
<p>示例 2:</p>
<pre><code>[[0,0,0,0,0,0,0,0]]

对于上面这个给定的矩阵, 返回 0。
</code></pre>
<p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p>
<p><strong>思路：</strong> 利用深度优先搜索DFS，把接下来要遍历的土地加入到栈里。访问每一片土地时，都对他的四个方向进行探索，找到未访问的土地，加入到栈中，只要栈不为空，就说明还有土地待访问，那么就从栈中取出一个元素并访问。为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 0。这样我们就不会多次访问同一土地。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid</span>):</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, m <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(m):</span><br><span class="line">                area = <span class="number">0</span></span><br><span class="line">                stack = [(i,j)]</span><br><span class="line">                <span class="keyword">while</span> stack:  <span class="comment"># 当栈为空表示无路可走，返回上一层循环</span></span><br><span class="line">                    x, y = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> x == <span class="built_in">len</span>(grid) <span class="keyword">or</span> y == <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[x][y] != <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    area += <span class="number">1</span>  <span class="comment"># 连通岛屿面积+1</span></span><br><span class="line">                    grid[x][y] = <span class="number">0</span>  <span class="comment"># 将已经访问过的点置为0，避免再次访问</span></span><br><span class="line">                    <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)]:</span><br><span class="line">                        new_x = x + dx</span><br><span class="line">                        new_y = y + dy</span><br><span class="line">                        stack.append((new_x,new_y))</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, area)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1:</p>
<pre><code>输入:
11110
11010
11000
00000
输出: 1
</code></pre>
<p>示例 2:</p>
<pre><code>输入:
11000
11000
00100
00011
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
</code></pre>
<p><strong>思路：</strong> 使用DFS，遍历整个矩阵，当遇到 grid[ i ][ j ] &#x3D;&#x3D; ‘1’时，对该点的上下左右进行深度优先搜索，岛屿数num+1。探索岛屿的同时将 grid[ i ][ j ] &#x3D;&#x3D; ‘0’，避免之后重复搜索相同的岛屿。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] != <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            grid[i][j] = <span class="string">&#x27;0&#x27;</span>  <span class="comment"># 已访问过的节点置为0</span></span><br><span class="line">            <span class="comment"># for new_i,new_j in [(i,j+1),(i,j-1),(i-1,j),(i+1,j)]:</span></span><br><span class="line">            <span class="comment">#     if 0&lt;= new_i &lt; len(grid) and 0&lt;= new_j &lt; len(grid[0]) and grid[new_i][new_j] == &#x27;1&#x27;:</span></span><br><span class="line">            <span class="comment">#         dfs(grid,new_i,new_j)</span></span><br><span class="line">            dfs(grid, i+<span class="number">1</span>, j)</span><br><span class="line">            dfs(grid, i, j+<span class="number">1</span>)</span><br><span class="line">            dfs(grid, i-<span class="number">1</span>, j)</span><br><span class="line">            dfs(grid, i, j-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    dfs(grid, i, j)</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

<h3 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547. 朋友圈"></a>547. 朋友圈</h3><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] &#x3D; 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>
<p>示例 1:</p>
<pre><code>输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。
</code></pre>
<p>示例 2:</p>
<pre><code>输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
</code></pre>
<p>注意：</p>
<pre><code>N 在[1,200]的范围内。
对于所有学生，有M[i][i] = 1。
如果有M[i][j] = 1，则有M[j][i] = 1。
</code></pre>
<p><strong>思路：</strong> 本题中的每个人都可以看作一个节点，如果两个人互为朋友，那么这两个节点之间就有一条边相连。因为该题表示的是朋友关系，所以二维表的长宽一定相等(长度宽度都表示共有几个人)，利用深度优先搜索dfs，先访问一个节点，再访问其相邻的任一节点，再访问这一节点的任一相邻节点，不断遍历没有访问过的节点。这一过程相当于去询问每个人，让他说出跟谁是朋友，每个人只用问一遍，所以用一个一维列表记录是否访问过该节点即可。所以在主代码设置一层循环，dfs函数里设置一层循环；在主代码首先访问第0个人，进入dfs深度优先搜索，如果在dfs中把剩下的所有人都访问到了，说明他们几个都是朋友，只在主代码里调用了一次dfs，就有一个朋友圈；如果在dfs中谁也访问不到，就说明第0个人没有朋友，他自己是一个朋友圈，就接着在主代码遍历第1个人，以此类推。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, M</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, visited</span>):</span><br><span class="line">            visited[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M)):</span><br><span class="line">                <span class="keyword">if</span> visited[j] == <span class="number">0</span> <span class="keyword">and</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dfs(j, visited)</span><br><span class="line"></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M)):</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">                dfs(i, visited)</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h3><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<pre><code>X X X X
X O O X
X X O X
X O X X

运行你的函数后，矩阵变为：

X X X X
X X X X
X X X X
X O X X
</code></pre>
<p>解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<p><strong>思路：</strong> 从边界开始深度优先搜索，把”O”和与边界”O”连通的”O”置为”Y”，然后再遍历整个二维数组，把”O”置为”X”，把”Y”置为”O”。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self, board</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">board, i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(board) <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            board[i][j] = <span class="string">&quot;Y&quot;</span>   <span class="comment"># 把与边界连通的&quot;O&quot;变成&quot;Y&quot;</span></span><br><span class="line">            dfs(board, i, j-<span class="number">1</span>)</span><br><span class="line">            dfs(board, i, j+<span class="number">1</span>)</span><br><span class="line">            dfs(board, i-<span class="number">1</span>, j)</span><br><span class="line">            dfs(board, i+<span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(board) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">&quot;O&quot;</span>:   <span class="comment"># 第一列</span></span><br><span class="line">                dfs(board, i, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> board[i][<span class="built_in">len</span>(board[<span class="number">0</span>])-<span class="number">1</span>] == <span class="string">&quot;O&quot;</span>:   <span class="comment"># 最后一列</span></span><br><span class="line">                dfs(board, i, <span class="built_in">len</span>(board[<span class="number">0</span>])-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> board[<span class="number">0</span>][j] == <span class="string">&quot;O&quot;</span>:   <span class="comment"># 第一行</span></span><br><span class="line">                dfs(board, <span class="number">0</span>, j)</span><br><span class="line">            <span class="keyword">if</span> board[<span class="built_in">len</span>(board)-<span class="number">1</span>][j] == <span class="string">&quot;O&quot;</span>:   <span class="comment"># 最后一行</span></span><br><span class="line">                dfs(board, <span class="built_in">len</span>(board)-<span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;O&quot;</span>:   <span class="comment"># 把&quot;O&quot;变成&quot;X&quot;</span></span><br><span class="line">                    board[i][j] = <span class="string">&quot;X&quot;</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">&quot;Y&quot;</span>:   <span class="comment"># 把&quot;Y&quot;变成&quot;O&quot;</span></span><br><span class="line">                    board[i][j] = <span class="string">&quot;O&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(board)</span><br></pre></td></tr></table></figure>

<h3 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a>417. 太平洋大西洋水流问题</h3><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p>
<p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p>
<p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p>
<p>提示：</p>
<pre><code>输出坐标的顺序不重要
m 和 n 都小于150
</code></pre>
<p>示例：</p>
<p>​	<br>    给定下面的 5x5 矩阵:</p>
<pre><code>  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
</code></pre>
<p><strong>思路：</strong> 本题按照水流方向正向找比较困难，而从大西洋或太平洋出发逆着水流找相对容易，利用DFS，找下一个高度大于等于当前点的位置，最后取同时被大西洋出发和太平洋出发遍历到的点，就是答案。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pacificAtlantic</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        res1, res2 = <span class="built_in">set</span>(), <span class="built_in">set</span>()  <span class="comment"># 流向太平洋与大西洋的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j, res</span>):</span><br><span class="line">            res.add((i,j))</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">                new_i = i + x</span><br><span class="line">                new_j = j + y</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=new_i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=new_j&lt;n <span class="keyword">and</span> matrix[i][j] &lt;= matrix[new_i][new_j] \</span><br><span class="line">                        <span class="keyword">and</span> (new_i,new_j) <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    dfs(new_i, new_j, res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):   <span class="comment"># 从左侧的太平洋开始</span></span><br><span class="line">            dfs(i, <span class="number">0</span>, res1)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):   <span class="comment"># 从上方的太平洋开始</span></span><br><span class="line">            dfs(<span class="number">0</span>, j, res1)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):   <span class="comment"># 从右侧的大西洋开始</span></span><br><span class="line">            dfs(i, n-<span class="number">1</span>, res2)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):   <span class="comment"># 从下方的大西洋开始</span></span><br><span class="line">            dfs(m-<span class="number">1</span>, j, res2)</span><br><span class="line">        <span class="keyword">return</span> res1 &amp; res2   <span class="comment"># 两个位置结果取交集</span></span><br></pre></td></tr></table></figure>

<h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="/2021/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89/20200606113748791.png" alt="在这里插入图片描述"><br>示例:</p>
<pre><code>输入：&quot;23&quot;
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre>
<p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<p><strong>思路：</strong><br><img src="/2021/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89/20200606113851594.png" alt="在这里插入图片描述">这类让求全排列的问题，通常都是使用回溯法。关于回溯法，推荐看这篇文章：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/</a></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="built_in">hash</span> = &#123;<span class="string">&quot;2&quot;</span>:[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>],<span class="string">&quot;3&quot;</span>:[<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>],<span class="string">&quot;4&quot;</span>:[<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>],</span><br><span class="line">                <span class="string">&quot;5&quot;</span>:[<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>],<span class="string">&quot;6&quot;</span>:[<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>],<span class="string">&quot;7&quot;</span>:[<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>],</span><br><span class="line">                <span class="string">&quot;8&quot;</span>:[<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>],<span class="string">&quot;9&quot;</span>:[<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">conbination, nextdigit</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nextdigit) == <span class="number">0</span>:</span><br><span class="line">                res.append(conbination)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> <span class="built_in">hash</span>[nextdigit[<span class="number">0</span>]]:</span><br><span class="line">                backtrack(conbination + letter, nextdigit[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="string">&#x27;&#x27;</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 ‘.’ 分隔。</p>
<p>示例:</p>
<pre><code>输入: &quot;25525511135&quot;
输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]
</code></pre>
<p><strong>思路：</strong> 使用回溯法，根据IP地址的规则限制，每次只能截取一位、两位或三位；截取一位没有规则限制；截取两位需要保证最左不能为0；截取三位需要保证最左不能为0且这三位数不能大于256。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>):</span><br><span class="line">        r = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">restore</span>(<span class="params">count=<span class="number">0</span>, ip=<span class="string">&#x27;&#x27;</span>, s=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                    r.append(ip[:-<span class="number">1</span>])   <span class="comment"># 最后一个不取是因为最后一个是&quot;.&quot;</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:   <span class="comment"># 截取一位</span></span><br><span class="line">                restore(count+<span class="number">1</span>, ip+s[<span class="number">0</span>]+<span class="string">&#x27;.&#x27;</span>, s[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>:  <span class="comment"># 截取两位，且最左不能为0</span></span><br><span class="line">                restore(count+<span class="number">1</span>, ip+s[:<span class="number">2</span>]+<span class="string">&#x27;.&#x27;</span>, s[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">2</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> <span class="built_in">int</span>(s[<span class="number">0</span>:<span class="number">3</span>]) &lt; <span class="number">256</span>:  <span class="comment"># 截取三位，且最左不能为0，且这三位数不能大于256</span></span><br><span class="line">                restore(count+<span class="number">1</span>, ip+s[:<span class="number">3</span>]+<span class="string">&#x27;.&#x27;</span>, s[<span class="number">3</span>:])</span><br><span class="line">        restore(<span class="number">0</span>, <span class="string">&#x27;&#x27;</span>, s)</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h3><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例:</p>
<pre><code>board =
[
  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],
  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],
  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]
]

给定 word = &quot;ABCCED&quot;, 返回 true
给定 word = &quot;SEE&quot;, 返回 true
给定 word = &quot;ABCB&quot;, 返回 false
</code></pre>
<p>提示：</p>
<pre><code>    board 和 word 中只包含大写和小写英文字母。
    1 &lt;= board.length &lt;= 200
    1 &lt;= board[i].length &lt;= 200
    1 &lt;= word.length &lt;= 10^3
</code></pre>
<p><strong>思路：</strong> 对每个格子都要从头搜索，如果搜索不到返回False，只要有一个搜索到就返回True。在DFS时，如果遇到不匹配的需要回溯并且状态重置。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    direction = [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">self, board, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">x, y, index</span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(word)-<span class="number">1</span>:   <span class="comment"># 递归终止条件</span></span><br><span class="line">                <span class="keyword">return</span> board[x][y] == word[index]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> board[x][y] == word[index]:</span><br><span class="line">                mark[x][y] = <span class="literal">True</span>   <span class="comment"># 先把位置标记为已访问，如果下一个不匹配则要释放</span></span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> self.direction:</span><br><span class="line">                    new_x = x + <span class="built_in">dir</span>[<span class="number">0</span>]</span><br><span class="line">                    new_y = y + <span class="built_in">dir</span>[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= new_x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= new_y &lt; n <span class="keyword">and</span> <span class="keyword">not</span> mark[new_x][new_y] \</span><br><span class="line">                            <span class="keyword">and</span> backtrack(new_x,new_y,index+<span class="number">1</span>):</span><br><span class="line">                        <span class="comment"># 说明一路搜索到最后</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                mark[x][y] = <span class="literal">False</span>  <span class="comment"># 回溯，将这个位置释放为未访问状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(board)</span><br><span class="line">        n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        mark = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 对每个格子都从头开始搜</span></span><br><span class="line">                <span class="keyword">if</span> backtrack(i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<pre><code>输入:

   1
 /   \
2     3
 \
  5

输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3
</code></pre>
<p><strong>思路：</strong> 利用path存储每次走的路径，用res存储最终结果。从根节点开始一直往下找，假如到达叶子节点则把这条路径添加到res；假如不是叶子节点就继续递归，每次递归都在路径里加上 “-&gt;” 作为连接符。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">root, path</span>):</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                path += <span class="built_in">str</span>(root.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment"># 叶子节点</span></span><br><span class="line">                    res.append(path)</span><br><span class="line">                <span class="keyword">else</span>:   <span class="comment"># 非叶子节点</span></span><br><span class="line">                    path += <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">                    backtrack(root.left, path)</span><br><span class="line">                    backtrack(root.right, path)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(root,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h3><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<pre><code>输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre>
<p><strong>思路：</strong> 全排列问题，用回溯法，每次递归循环都将当前值加入列表，把除去当前值的剩下值再作为参数传入，进行下一个递归。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums, li</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                res.append(li)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                backtrack(nums[:i]+nums[i+<span class="number">1</span>:], li+[nums[i]])  <span class="comment"># 利用列表的加法</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(nums,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h3><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例:</p>
<pre><code>输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre>
<p><strong>思路：</strong> 本题在46题基础上，增加了重复数，为了提高效率，需要在深搜过程中合理剪枝。首先把数组排序，使得重复的数挨在一起，在深搜函数遍历数组那里，先对每个数进行判断，如果当前数和他前一个数相等，就不对他进行深搜。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums</span>) :</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">nums,li</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                res.append(li)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:  <span class="comment"># 不对重复的数进行深搜</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(nums[:i] + nums[i+<span class="number">1</span>:], li+[nums[i]])</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()   <span class="comment"># 这里排序可以保证把重复的数放在一起以便被检测到</span></span><br><span class="line">        backtrack(nums,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h3><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:</p>
<pre><code>输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</code></pre>
<p><strong>思路：</strong> 利用回溯，用i来控制每次从哪个数开始深搜，用k来控制深搜的个数(k个数的组合)。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">i,k,li</span>):</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                res.append(li)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(i,n+<span class="number">1</span>):</span><br><span class="line">                backtrack(i+<span class="number">1</span>, k-<span class="number">1</span>, li+[i])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="number">1</span>,k,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h3><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<pre><code>所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
</code></pre>
<p>示例 1:</p>
<pre><code>输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
</code></pre>
<p>示例 2:</p>
<pre><code>输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</code></pre>
<p><strong>思路：</strong> 利用回溯，每个数可以重复使用任意次，对于数组中每个数nums[i]，在递归时就有选与不选两种情况：1.如果选nums[i]，递归到下一层时，由于nums[i]可以重复使用，因此下一层的起始下标还是i，但temp和target发生变化；2.如果不选nums[i]，递归到下一层时，由于在这一层递归的时候什么都不做，因此temp和target不用变化，但i需要+1。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates, target: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> candidates):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = <span class="built_in">len</span>(candidates)</span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()   <span class="comment"># 排序是为了后面判断target是否小于候选数，以便剪枝</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">i, tmp, target</span>):</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>):</span><br><span class="line">                res.append(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> (i == n <span class="keyword">or</span> target &lt; candidates[i]):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(i, tmp + [candidates[i]], target - candidates[i])</span><br><span class="line">            helper(i + <span class="number">1</span>, tmp, target)</span><br><span class="line"></span><br><span class="line">        helper(<span class="number">0</span>, [], target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<pre><code>所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
</code></pre>
<p>示例 1:</p>
<pre><code>输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
</code></pre>
<p>示例 2:</p>
<pre><code>输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
</code></pre>
<p><strong>思路：</strong> 利用回溯，重点在于避免重复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例1               1</span><br><span class="line">                 / \</span><br><span class="line">                2   2  这种情况不会发生 但是却允许了不同层级之间的重复即：</span><br><span class="line">               /     \</span><br><span class="line">              5       5</span><br><span class="line">               </span><br><span class="line">例2               1</span><br><span class="line">                 /</span><br><span class="line">                2      这种情况确是允许的</span><br><span class="line">               /</span><br><span class="line">              2  </span><br></pre></td></tr></table></figure>

<p>首先 i-1 &#x3D;&#x3D; i 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 因为当第二个2出现的时候，他就和前一个2相同了。</p>
<p>那么如何保留例2呢？就用 i &gt; begin 来避免这种情况，你发现例1中的两个2是处在同一个层级上的，例2的两个2是处在不同层级上的。在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。第一个出现的2的特点就是 i &#x3D;&#x3D; begin. 第二个出现的2 特点是 i &gt; begin。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates, target: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">begin, li, target</span>):</span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(li[:])   <span class="comment"># li[:]是对li作浅拷贝，与li地址不同，对li的pop并不影响li[:]</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin,<span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> target &lt; candidates[i]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; begin <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                li.append(candidates[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, li, target-candidates[i])</span><br><span class="line">                li.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="number">0</span>, [], target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h3><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<pre><code>所有数字都是正整数。
解集不能包含重复的组合。 
</code></pre>
<p>示例 1:</p>
<pre><code>输入: k = 3, n = 7
输出: [[1,2,4]]
</code></pre>
<p>示例 2:</p>
<pre><code>输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
</code></pre>
<p><strong>思路：</strong> 利用回溯，count表示当前已经使用的数字数，index表示当前访问的数字，li记录当前中间结果，target表示下一步的目标和。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">count, index, li, target</span>):</span><br><span class="line">            <span class="keyword">if</span> count == k:</span><br><span class="line">                <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                    res.append(li)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                backtrack(count+<span class="number">1</span>, j+<span class="number">1</span>, li+[j], target-j)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">1</span>, [], n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h3><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<pre><code>输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre>
<p><strong>思路：</strong> 利用回溯，不用符合某个条件再把 li 添加到 res 中，每次循环都 append 当前 li 到 res 中。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">i,li</span>):</span><br><span class="line">            res.append(li)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(nums)):</span><br><span class="line">                backtrack(j+<span class="number">1</span>, li+[nums[j]])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h3><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<pre><code>输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</code></pre>
<p><strong>思路：</strong> 为了去除重复的子集，第一时间想到排序。利用回溯，其余的处理和78题与40题类似。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">index,li</span>):</span><br><span class="line">            res.append(li)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(index,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> j &gt; index <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(j+<span class="number">1</span>,li+[nums[j]])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        backtrack(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h3><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例:</p>
<pre><code>输入: &quot;aab&quot;
输出:
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
</code></pre>
<p><strong>思路：</strong> 利用回溯，每次遍历检查当前字符串是否是回文串。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">s, li</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                res.append(li)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[:i] == s[:i][::-<span class="number">1</span>]:</span><br><span class="line">                    backtrack(s[i:], li+[s[:i]])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(s, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h3><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需遵循如下规则：</p>
<pre><code>数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
</code></pre>
<p>空白格用 ‘.’ 表示。<br><img src="/2021/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89/20200606123311642.png" alt="在这里插入图片描述"><br>一个数独。<br><img src="/2021/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89/20200606123319640.png" alt="在这里插入图片描述"><br>答案被标成红色。</p>
<p>Note:</p>
<pre><code>给定的数独序列只包含数字 1-9 和字符 &#39;.&#39; 。
你可以假设给定的数独只有唯一解。
给定数独永远是 9x9 形式的。
</code></pre>
<p><strong>思路：</strong> 一个回溯函数backtrack对board[i][j] 进行穷举尝试，一个isValid函数判断要填入的数字是否合法(符合数独规则)。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveSudoku</span>(<span class="params">self, board</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 对 board[i][j] 进行穷举尝试</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">board, i, j</span>):</span><br><span class="line">            m, n = <span class="number">9</span>, <span class="number">9</span></span><br><span class="line">            <span class="keyword">if</span> j == n:   <span class="comment"># 走到9才越界，进入下一行</span></span><br><span class="line">                <span class="keyword">return</span> backtrack(board, i+<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> i == m:   <span class="comment"># 走到最后一行，找到一个可行解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;.&#x27;</span>:   <span class="comment"># 当前是预设数字，直接跳到下一个</span></span><br><span class="line">                <span class="keyword">return</span> backtrack(board, i, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            ch_list = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>]</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> ch_list:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isValid(board, i, j, ch):   <span class="comment"># 如果遇到不合法的数字，则跳过</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                board[i][j] = ch   <span class="comment"># 做选择</span></span><br><span class="line">                <span class="keyword">if</span> backtrack(board, i, j+<span class="number">1</span>):  <span class="comment"># 如果找到一个可行解，立即结束</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                board[i][j] = <span class="string">&#x27;.&#x27;</span>   <span class="comment"># 撤销选择</span></span><br><span class="line">            <span class="comment"># 穷举完 1~9，依然没有找到可行解，此路不通</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断 board[i][j] 是否可以填入 n</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">board, r, c, n</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="comment"># 判断行是否存在重复</span></span><br><span class="line">                <span class="keyword">if</span> board[r][i] == n: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断列是否存在重复</span></span><br><span class="line">                <span class="keyword">if</span> board[i][c] == n: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 判断 3 * 3 方框是否存在重复</span></span><br><span class="line">                <span class="keyword">if</span> board[(r//<span class="number">3</span>)*<span class="number">3</span> + i//<span class="number">3</span>][(c//<span class="number">3</span>)*<span class="number">3</span> + i%<span class="number">3</span>] == n:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        backtrack(board, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h3><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br><img src="/2021/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89/20200606142245696.png" alt="在这里插入图片描述"><br>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例:</p>
<pre><code>输入: 4
输出: [
 [&quot;.Q..&quot;,  // 解法 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // 解法 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
解释: 4 皇后问题存在两个不同的解法。
</code></pre>
<p>提示： 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。（引用自 百度百科 - 皇后 ）</p>
<p><strong>思路：</strong> 本题与37数独题不相同的地方在于如果已经在某行某列放置了皇后，那么该行就不可能再放置皇后了，直接进入下一行。并且要注意触发结束条件时，把所有结果放在二维列表返回。由于是一行一行搜索，当前行上面是已经放置皇后的，下面还是空棋盘，在判断当前位置是否合法时，只用查看同列以及左斜上方和右斜上方是否有皇后互相冲突即可。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        board = [[<span class="string">&#x27;.&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 初始化空棋盘</span></span><br><span class="line">        <span class="comment"># 路径：board中小于row的那些行都已经成功放置了皇后</span></span><br><span class="line">        <span class="comment"># 选择列表：第row行的左右列都是放置皇后的选择</span></span><br><span class="line">        <span class="comment"># 结束条件：row超过board的最后一行</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">board, row</span>):</span><br><span class="line">            <span class="keyword">if</span> row == n:  <span class="comment"># 触发结束条件</span></span><br><span class="line">                li = []</span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> board:</span><br><span class="line">                    li.append(<span class="string">&quot;&quot;</span>.join(row))</span><br><span class="line">                res.append(li)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isValid(board,row,col):   <span class="comment"># 排除不合法选择</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                board[row][col] = <span class="string">&#x27;Q&#x27;</span>   <span class="comment"># 做选择</span></span><br><span class="line">                backtrack(board, row+<span class="number">1</span>)   <span class="comment"># 进入下一行</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span>   <span class="comment"># 撤销选择</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断 board[row][col] 是否可以填入 &#x27;Q&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">board, row, col</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][col] == <span class="string">&#x27;Q&#x27;</span>:   <span class="comment"># 检查列是否有皇后互相冲突</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            i, j = row-<span class="number">1</span>, col+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n:   <span class="comment"># 检查右斜上方是否有皇后互相冲突</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            i, j = row-<span class="number">1</span>, col-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:   <span class="comment"># 检查左斜上方是否有皇后互相冲突</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(board, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<ul>
<li>题目全部出自LeetCode官网：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/">https://leetcode-cn.com/</a></li>
<li>题目分类参考这篇文章：<a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">JoeXu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dr_BigJoe/article/details/106530391">https://blog.csdn.net/Dr_BigJoe/article/details/106530391</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">以上为个人学习笔记总结，供学习参考交流，转载请注明出处。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/67886383?s=400&amp;u=99fc4b7b2788d8823a12f2924f7942669b39b105&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/05/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E5%9B%9B%EF%BC%89/" title="【LeetCode刷题笔记】— 算法思想（四）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">【LeetCode刷题笔记】— 算法思想（四）</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/01/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%BA%8C%EF%BC%89/" title="【LeetCode刷题笔记】— 算法思想（二）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">【LeetCode刷题笔记】— 算法思想（二）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/07/31/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89/" title="【LeetCode刷题笔记】— 算法思想（一）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-31</div><div class="title">【LeetCode刷题笔记】— 算法思想（一）</div></div></a></div><div><a href="/2021/04/14/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%BA%94%EF%BC%89/" title="【LeetCode刷题笔记】— 算法思想（五）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-14</div><div class="title">【LeetCode刷题笔记】— 算法思想（五）</div></div></a></div><div><a href="/2021/03/01/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%BA%8C%EF%BC%89/" title="【LeetCode刷题笔记】— 算法思想（二）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-01</div><div class="title">【LeetCode刷题笔记】— 算法思想（二）</div></div></a></div><div><a href="/2021/03/05/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E5%9B%9B%EF%BC%89/" title="【LeetCode刷题笔记】— 算法思想（四）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-05</div><div class="title">【LeetCode刷题笔记】— 算法思想（四）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/67886383?s=400&amp;u=99fc4b7b2788d8823a12f2924f7942669b39b105&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Joe Xu</div><div class="author-info__description">Stay hungry, Stay Foolish</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JoeXu727" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%88%E4%B8%89%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">【LeetCode刷题笔记】— 算法思想（三）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%88%86%E6%B2%BB"><span class="toc-number">1.1.</span> <span class="toc-text">五、分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#241-%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">241. 为运算表达式设计优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">96. 不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="toc-number">1.1.3.</span> <span class="toc-text">95. 不同的二叉搜索树 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%90%9C%E7%B4%A2"><span class="toc-number">1.2.</span> <span class="toc-text">六、搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS"><span class="toc-number">1.3.</span> <span class="toc-text">BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">1091. 二进制矩阵中的最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">279. 完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="toc-number">1.3.3.</span> <span class="toc-text">127. 单词接龙</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS"><span class="toc-number">1.4.</span> <span class="toc-text">DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">695. 岛屿的最大面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">200. 岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#547-%E6%9C%8B%E5%8F%8B%E5%9C%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">547. 朋友圈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">130. 被围绕的区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.5.</span> <span class="toc-text">417. 太平洋大西洋水流问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking"><span class="toc-number">1.5.</span> <span class="toc-text">Backtracking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">17. 电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-number">1.5.2.</span> <span class="toc-text">93. 复原IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">1.5.3.</span> <span class="toc-text">79. 单词搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">1.5.4.</span> <span class="toc-text">257. 二叉树的所有路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">1.5.5.</span> <span class="toc-text">46. 全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="toc-number">1.5.6.</span> <span class="toc-text">47. 全排列 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88"><span class="toc-number">1.5.7.</span> <span class="toc-text">77. 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">1.5.8.</span> <span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-number">1.5.9.</span> <span class="toc-text">40. 组合总和 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="toc-number">1.5.10.</span> <span class="toc-text">216. 组合总和 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-number">1.5.11.</span> <span class="toc-text">78. 子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-%E5%AD%90%E9%9B%86-II"><span class="toc-number">1.5.12.</span> <span class="toc-text">90. 子集 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">1.5.13.</span> <span class="toc-text">131. 分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="toc-number">1.5.14.</span> <span class="toc-text">37. 解数独</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E"><span class="toc-number">1.5.15.</span> <span class="toc-text">51. N皇后</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/17/%E3%80%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%95%E6%93%8E%E5%AE%9E%E6%88%98%E3%80%91%E2%80%94%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6-%E5%A4%9A%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/" title="【阿里低代码引擎实战】— 自定义插件-多页面管理（二）">【阿里低代码引擎实战】— 自定义插件-多页面管理（二）</a><time datetime="2024-03-17T07:23:30.000Z" title="Created 2024-03-17 15:23:30">2024-03-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/10/%E3%80%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%95%E6%93%8E%E5%AE%9E%E6%88%98%E3%80%91%E2%80%94%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6-%E5%A4%9A%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/" title="【阿里低代码引擎实战】— 自定义插件-多页面管理（一）">【阿里低代码引擎实战】— 自定义插件-多页面管理（一）</a><time datetime="2024-03-10T08:23:30.000Z" title="Created 2024-03-10 16:23:30">2024-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/03/%E3%80%90%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF%E3%80%91%E2%80%94%20%E8%A7%A3%E5%86%B3GitHub%20push%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99403/" title="【踩坑之路】— 解决GitHub push代码报错403">【踩坑之路】— 解决GitHub push代码报错403</a><time datetime="2024-03-03T12:24:30.000Z" title="Created 2024-03-03 20:24:30">2024-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/02/%E3%80%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%95%E6%93%8E%E5%AE%9E%E6%88%98%E3%80%91%E2%80%94%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%A9%E6%96%99%E6%8E%A5%E5%85%A5demo(%E5%86%85%E5%90%ABnpm%E5%8F%91%E5%8C%85%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4)/" title="【阿里低代码引擎实战】— 自定义物料接入demo(内含npm发包详细步骤)">【阿里低代码引擎实战】— 自定义物料接入demo(内含npm发包详细步骤)</a><time datetime="2024-03-02T03:03:30.000Z" title="Created 2024-03-02 11:03:30">2024-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/24/%E3%80%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%95%E6%93%8E%E5%AE%9E%E6%88%98%E3%80%91%E2%80%94%20%E5%AE%89%E8%A3%85WSL%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE/" title="【阿里低代码引擎实战】— 安装WSL与初始化项目">【阿里低代码引擎实战】— 安装WSL与初始化项目</a><time datetime="2024-02-24T02:35:02.000Z" title="Created 2024-02-24 10:35:02">2024-02-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Joe Xu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>